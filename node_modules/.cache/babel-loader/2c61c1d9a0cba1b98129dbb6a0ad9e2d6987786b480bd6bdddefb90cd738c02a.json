{"ast":null,"code":"// attio.js\nconst ATTIO_API_BASE = \"https://api.attio.com/v2\";\nconst BEARER_TOKEN = \"Bearer e01cca9d5d70d62535755e3f1609118082790728f8c98dbd0b3f9cce1aae3f53\";\nconst objectCache = {}; // caches object_ids like \"people\"\nconst attributeCache = {}; // caches attribute mappings\n\n// You'll need to get these from your Attio workspace\nconst ATTRIBUTE_IDS = {\n  name: \"3a2d79ac-1c54-4d1d-9bd1-df92ba80052f\",\n  email: \"4ab52dd0-edfe-4eea-b73c-561028076ea6\",\n  // You'll need to find this ID\n  phone: \"57e614f6-a910-4df8-a7a5-f175d85a8825\",\n  // You'll need to find this ID\n  notes: \"168ddd0a-6dc6-4aff-8939-60dcfe1cdf41\" // You'll need to find this ID\n};\nasync function sendToAttio(updates) {\n  console.log('üîÑ Processing updates:', updates);\n\n  // Group updates by person to handle linking\n  const personUpdates = updates.filter(item => item.type === \"person\");\n  const taskUpdates = updates.filter(item => item.type === \"task\");\n  const processedPersons = {};\n\n  // Process persons first\n  for (const item of personUpdates) {\n    try {\n      ensureFields(item);\n      const personId = await upsertPerson(item);\n      processedPersons[item.name] = personId;\n    } catch (err) {\n      console.error(\"‚ùå Failed to process person:\", item, err);\n    }\n  }\n\n  // Process tasks and link to persons\n  for (const item of taskUpdates) {\n    try {\n      ensureFields(item);\n\n      // Find the person to link to\n      let linkedPersonId = null;\n      if (item.link_to_person_name) {\n        linkedPersonId = processedPersons[item.link_to_person_name];\n        if (!linkedPersonId) {\n          var _existingPerson$id;\n          // Try to find existing person\n          const existingPerson = await queryPersonByName(item.link_to_person_name);\n          linkedPersonId = existingPerson === null || existingPerson === void 0 ? void 0 : (_existingPerson$id = existingPerson.id) === null || _existingPerson$id === void 0 ? void 0 : _existingPerson$id.record_id;\n        }\n      }\n      await upsertTask(item, linkedPersonId);\n    } catch (err) {\n      console.error(\"‚ùå Failed to process task:\", item, err);\n    }\n  }\n}\nfunction ensureFields(item) {\n  if (item.type === \"person\") {\n    item.name = item.name || \"Unknown\";\n    item.notes = item.notes || \"\";\n    const [first, ...rest] = item.name.split(\" \");\n    item.first_name = item.first_name || first || \"Unknown\";\n    item.last_name = item.last_name || rest.join(\" \") || \"\";\n  }\n  if (item.type === \"task\") {\n    item.description = item.description || item.name || \"Untitled task\";\n    item.due_date = parseDateTime(item.due_date, item.due_time);\n  }\n}\nfunction parseDateTime(date, time) {\n  try {\n    let d = new Date();\n    if (date !== null && date !== void 0 && date.toLowerCase().includes(\"tomorrow\")) {\n      d.setDate(d.getDate() + 1);\n    } else if (date !== null && date !== void 0 && date.toLowerCase().includes(\"next week\")) {\n      d.setDate(d.getDate() + 7);\n    } else if (Date.parse(date)) {\n      d = new Date(date);\n    }\n    if (time) {\n      const [t, mer] = time.split(\" \");\n      let [h, m] = t.split(\":\").map(Number);\n      if (mer !== null && mer !== void 0 && mer.includes(\"p\") && h < 12) h += 12;\n      if (mer !== null && mer !== void 0 && mer.includes(\"a\") && h === 12) h = 0;\n      d.setHours(h || 0, m || 0, 0, 0);\n    }\n    return d.toISOString();\n  } catch {\n    // Default to next week\n    const nextWeek = new Date();\n    nextWeek.setDate(nextWeek.getDate() + 7);\n    return nextWeek.toISOString();\n  }\n}\nasync function getObjectIdBySlug(slug) {\n  var _json$data, _json$data$id;\n  if (objectCache[slug]) return objectCache[slug];\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${slug}`, {\n    headers: {\n      Authorization: BEARER_TOKEN\n    }\n  });\n  if (!res.ok) {\n    throw new Error(`Failed to get object ${slug}: ${res.status}`);\n  }\n  const json = await res.json();\n  const id = (_json$data = json.data) === null || _json$data === void 0 ? void 0 : (_json$data$id = _json$data.id) === null || _json$data$id === void 0 ? void 0 : _json$data$id.object_id;\n  if (!id) throw new Error(`‚ùå Cannot resolve object slug: ${slug}`);\n  objectCache[slug] = id;\n  return id;\n}\n\n// ========== PERSONS ==========\n\nasync function upsertPerson(data) {\n  console.log('üîÑ Upserting person:', data.name);\n\n  // First, try to find existing person\n  const existingPerson = await queryPersonByName(data.name);\n  if (existingPerson) {\n    console.log('üë§ Found existing person, updating:', existingPerson.id.record_id);\n    return await updatePerson(existingPerson.id.record_id, data);\n  } else {\n    console.log('üë§ Creating new person:', data.name);\n    return await createPerson(data);\n  }\n}\nasync function createPerson(data) {\n  var _json$data3, _json$data3$id;\n  const peopleId = await getObjectIdBySlug(\"people\");\n  const fullName = `${data.first_name || \"\"} ${data.last_name || \"\"}`.trim();\n  const values = {\n    [ATTRIBUTE_IDS.name]: [{\n      first_name: data.first_name || \"Unknown\",\n      last_name: data.last_name || \"\",\n      full_name: fullName\n    }]\n  };\n\n  // Add email if provided\n  if (data.email && ATTRIBUTE_IDS.email) {\n    values[ATTRIBUTE_IDS.email] = [{\n      email_address: data.email\n    }];\n  }\n\n  // Add phone if provided\n  if (data.phone && ATTRIBUTE_IDS.phone) {\n    values[ATTRIBUTE_IDS.phone] = [{\n      phone_number: data.phone\n    }];\n  }\n\n  // Add notes if provided\n  if (data.notes && ATTRIBUTE_IDS.notes) {\n    values[ATTRIBUTE_IDS.notes] = data.notes;\n  }\n  const payload = JSON.stringify({\n    data: {\n      values\n    }\n  });\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records`, {\n    method: \"POST\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: payload\n  });\n  const json = await res.json();\n  if (!res.ok) {\n    console.error(\"‚ùå Person creation error:\", json);\n    throw new Error(`Failed to create person: ${JSON.stringify(json)}`);\n  } else {\n    var _json$data2, _json$data2$id;\n    console.log(\"‚úÖ Person created:\", (_json$data2 = json.data) === null || _json$data2 === void 0 ? void 0 : (_json$data2$id = _json$data2.id) === null || _json$data2$id === void 0 ? void 0 : _json$data2$id.record_id);\n  }\n  return (_json$data3 = json.data) === null || _json$data3 === void 0 ? void 0 : (_json$data3$id = _json$data3.id) === null || _json$data3$id === void 0 ? void 0 : _json$data3$id.record_id;\n}\nasync function updatePerson(recordId, data) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  const values = {};\n\n  // Update name if provided\n  if (data.first_name || data.last_name) {\n    const fullName = `${data.first_name || \"\"} ${data.last_name || \"\"}`.trim();\n    values[ATTRIBUTE_IDS.name] = [{\n      first_name: data.first_name || \"Unknown\",\n      last_name: data.last_name || \"\",\n      full_name: fullName\n    }];\n  }\n\n  // Update email if provided\n  if (data.email && ATTRIBUTE_IDS.email) {\n    values[ATTRIBUTE_IDS.email] = [{\n      email_address: data.email\n    }];\n  }\n\n  // Update phone if provided\n  if (data.phone && ATTRIBUTE_IDS.phone) {\n    values[ATTRIBUTE_IDS.phone] = [{\n      phone_number: data.phone\n    }];\n  }\n\n  // Update notes if provided (append to existing notes)\n  if (data.notes && ATTRIBUTE_IDS.notes) {\n    values[ATTRIBUTE_IDS.notes] = data.notes;\n  }\n  if (Object.keys(values).length === 0) {\n    console.log('‚ÑπÔ∏è No updates needed for person');\n    return recordId;\n  }\n  const payload = JSON.stringify({\n    data: {\n      values\n    }\n  });\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records/${recordId}`, {\n    method: \"PATCH\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: payload\n  });\n  const json = await res.json();\n  if (!res.ok) {\n    console.error(\"‚ùå Person update error:\", json);\n    throw new Error(`Failed to update person: ${JSON.stringify(json)}`);\n  } else {\n    console.log(\"‚úÖ Person updated:\", recordId);\n  }\n  return recordId;\n}\nasync function queryPersonByName(name) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n\n  // Try exact match first\n  let payload = {\n    filter: {\n      and: [{\n        attribute: ATTRIBUTE_IDS.name,\n        query: name\n      }]\n    },\n    limit: 1\n  };\n  let res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records/query`, {\n    method: \"POST\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n  let json = await res.json();\n  if (json.data && json.data.length > 0) {\n    return json.data[0];\n  }\n\n  // Try fuzzy search if exact match fails\n  const [firstName, lastName] = name.split(\" \");\n  if (firstName) {\n    payload = {\n      filter: {\n        and: [{\n          attribute: ATTRIBUTE_IDS.name,\n          query: firstName\n        }]\n      },\n      limit: 5\n    };\n    res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records/query`, {\n      method: \"POST\",\n      headers: {\n        Authorization: BEARER_TOKEN,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(payload)\n    });\n    json = await res.json();\n\n    // Look for best match\n    if (json.data && json.data.length > 0) {\n      for (const person of json.data) {\n        var _person$values$ATTRIB, _person$values$ATTRIB2, _person$values$ATTRIB3;\n        const personName = (_person$values$ATTRIB = person.values[ATTRIBUTE_IDS.name]) === null || _person$values$ATTRIB === void 0 ? void 0 : (_person$values$ATTRIB2 = _person$values$ATTRIB[0]) === null || _person$values$ATTRIB2 === void 0 ? void 0 : (_person$values$ATTRIB3 = _person$values$ATTRIB2.full_name) === null || _person$values$ATTRIB3 === void 0 ? void 0 : _person$values$ATTRIB3.toLowerCase();\n        if (personName !== null && personName !== void 0 && personName.includes(name.toLowerCase())) {\n          return person;\n        }\n      }\n    }\n  }\n  return null;\n}\n\n// ========== TASKS ==========\n\nasync function upsertTask(data, linkedPersonId = null) {\n  console.log('üìã Creating task:', data.description);\n  const taskContent = data.description;\n  const payload = {\n    data: {\n      content: taskContent,\n      format: \"plaintext\",\n      deadline_at: data.due_date,\n      is_completed: false,\n      assignees: []\n    }\n  };\n\n  // Link to person if we have an ID\n  if (linkedPersonId) {\n    payload.data.linked_records = [{\n      target_object: \"people\",\n      target_record_id: linkedPersonId\n    }];\n  }\n  console.log(\"üì¶ Task payload:\", JSON.stringify(payload, null, 2));\n  const res = await fetch(`${ATTIO_API_BASE}/tasks`, {\n    method: \"POST\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n  const json = await res.json();\n  if (res.ok) {\n    var _json$data4, _json$data5;\n    console.log(\"‚úÖ Task created:\", (_json$data4 = json.data) === null || _json$data4 === void 0 ? void 0 : _json$data4.id);\n    return (_json$data5 = json.data) === null || _json$data5 === void 0 ? void 0 : _json$data5.id;\n  } else {\n    console.error(\"‚ùå Task creation failed:\", json);\n    throw new Error(`Failed to create task: ${JSON.stringify(json)}`);\n  }\n}\n\n// ========== UTILITY FUNCTIONS ==========\n\nasync function getAttributeIds(objectSlug) {\n  if (attributeCache[objectSlug]) return attributeCache[objectSlug];\n  const objectId = await getObjectIdBySlug(objectSlug);\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${objectId}/attributes`, {\n    headers: {\n      Authorization: BEARER_TOKEN\n    }\n  });\n  const json = await res.json();\n  const attributes = {};\n  if (json.data) {\n    json.data.forEach(attr => {\n      attributes[attr.api_slug] = attr.id.attribute_id;\n    });\n  }\n  attributeCache[objectSlug] = attributes;\n  console.log(`üìã Cached attributes for ${objectSlug}:`, attributes);\n  return attributes;\n}\n\n// Call this once to populate your attribute IDs\nasync function initializeAttributeIds() {\n  try {\n    const peopleAttributes = await getAttributeIds('people');\n    console.log('People attributes:', peopleAttributes);\n\n    // Update ATTRIBUTE_IDS with actual values\n    ATTRIBUTE_IDS.email = peopleAttributes.email_addresses;\n    ATTRIBUTE_IDS.phone = peopleAttributes.phone_numbers;\n    ATTRIBUTE_IDS.notes = peopleAttributes.notes;\n    console.log('‚úÖ Attribute IDs initialized');\n  } catch (err) {\n    console.error('‚ùå Failed to initialize attribute IDs:', err);\n  }\n}\nexport { sendToAttio, initializeAttributeIds };","map":{"version":3,"names":["ATTIO_API_BASE","BEARER_TOKEN","objectCache","attributeCache","ATTRIBUTE_IDS","name","email","phone","notes","sendToAttio","updates","console","log","personUpdates","filter","item","type","taskUpdates","processedPersons","ensureFields","personId","upsertPerson","err","error","linkedPersonId","link_to_person_name","_existingPerson$id","existingPerson","queryPersonByName","id","record_id","upsertTask","first","rest","split","first_name","last_name","join","description","due_date","parseDateTime","due_time","date","time","d","Date","toLowerCase","includes","setDate","getDate","parse","t","mer","h","m","map","Number","setHours","toISOString","nextWeek","getObjectIdBySlug","slug","_json$data","_json$data$id","res","fetch","headers","Authorization","ok","Error","status","json","data","object_id","updatePerson","createPerson","_json$data3","_json$data3$id","peopleId","fullName","trim","values","full_name","email_address","phone_number","payload","JSON","stringify","method","body","_json$data2","_json$data2$id","recordId","Object","keys","length","and","attribute","query","limit","firstName","lastName","person","_person$values$ATTRIB","_person$values$ATTRIB2","_person$values$ATTRIB3","personName","taskContent","content","format","deadline_at","is_completed","assignees","linked_records","target_object","target_record_id","_json$data4","_json$data5","getAttributeIds","objectSlug","objectId","attributes","forEach","attr","api_slug","attribute_id","initializeAttributeIds","peopleAttributes","email_addresses","phone_numbers"],"sources":["/Users/Aditya/ConversationalAI_CRM_Attio/src/attio.js"],"sourcesContent":["// attio.js\nconst ATTIO_API_BASE = \"https://api.attio.com/v2\";\nconst BEARER_TOKEN = \"Bearer e01cca9d5d70d62535755e3f1609118082790728f8c98dbd0b3f9cce1aae3f53\";\n\nconst objectCache = {}; // caches object_ids like \"people\"\nconst attributeCache = {}; // caches attribute mappings\n\n// You'll need to get these from your Attio workspace\nconst ATTRIBUTE_IDS = {\n  name: \"3a2d79ac-1c54-4d1d-9bd1-df92ba80052f\",\n  email: \"4ab52dd0-edfe-4eea-b73c-561028076ea6\", // You'll need to find this ID\n  phone: \"57e614f6-a910-4df8-a7a5-f175d85a8825\", // You'll need to find this ID\n  notes: \"168ddd0a-6dc6-4aff-8939-60dcfe1cdf41\"  // You'll need to find this ID\n};\n\n\nasync function sendToAttio(updates) {\n  console.log('üîÑ Processing updates:', updates);\n  \n  // Group updates by person to handle linking\n  const personUpdates = updates.filter(item => item.type === \"person\");\n  const taskUpdates = updates.filter(item => item.type === \"task\");\n  \n  const processedPersons = {};\n  \n  // Process persons first\n  for (const item of personUpdates) {\n    try {\n      ensureFields(item);\n      const personId = await upsertPerson(item);\n      processedPersons[item.name] = personId;\n    } catch (err) {\n      console.error(\"‚ùå Failed to process person:\", item, err);\n    }\n  }\n  \n  // Process tasks and link to persons\n  for (const item of taskUpdates) {\n    try {\n      ensureFields(item);\n      \n      // Find the person to link to\n      let linkedPersonId = null;\n      if (item.link_to_person_name) {\n        linkedPersonId = processedPersons[item.link_to_person_name];\n        if (!linkedPersonId) {\n          // Try to find existing person\n          const existingPerson = await queryPersonByName(item.link_to_person_name);\n          linkedPersonId = existingPerson?.id?.record_id;\n        }\n      }\n      \n      await upsertTask(item, linkedPersonId);\n    } catch (err) {\n      console.error(\"‚ùå Failed to process task:\", item, err);\n    }\n  }\n}\n\nfunction ensureFields(item) {\n  if (item.type === \"person\") {\n    item.name = item.name || \"Unknown\";\n    item.notes = item.notes || \"\";\n\n    const [first, ...rest] = item.name.split(\" \");\n    item.first_name = item.first_name || first || \"Unknown\";\n    item.last_name = item.last_name || rest.join(\" \") || \"\";\n  }\n\n  if (item.type === \"task\") {\n    item.description = item.description || item.name || \"Untitled task\";\n    item.due_date = parseDateTime(item.due_date, item.due_time);\n  }\n}\n\nfunction parseDateTime(date, time) {\n  try {\n    let d = new Date();\n    \n    if (date?.toLowerCase().includes(\"tomorrow\")) {\n      d.setDate(d.getDate() + 1);\n    } else if (date?.toLowerCase().includes(\"next week\")) {\n      d.setDate(d.getDate() + 7);\n    } else if (Date.parse(date)) {\n      d = new Date(date);\n    }\n\n    if (time) {\n      const [t, mer] = time.split(\" \");\n      let [h, m] = t.split(\":\").map(Number);\n      if (mer?.includes(\"p\") && h < 12) h += 12;\n      if (mer?.includes(\"a\") && h === 12) h = 0;\n      d.setHours(h || 0, m || 0, 0, 0);\n    }\n\n    return d.toISOString();\n  } catch {\n    // Default to next week\n    const nextWeek = new Date();\n    nextWeek.setDate(nextWeek.getDate() + 7);\n    return nextWeek.toISOString();\n  }\n}\n\nasync function getObjectIdBySlug(slug) {\n  if (objectCache[slug]) return objectCache[slug];\n\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${slug}`, {\n    headers: { Authorization: BEARER_TOKEN }\n  });\n\n  if (!res.ok) {\n    throw new Error(`Failed to get object ${slug}: ${res.status}`);\n  }\n\n  const json = await res.json();\n  const id = json.data?.id?.object_id;\n\n  if (!id) throw new Error(`‚ùå Cannot resolve object slug: ${slug}`);\n\n  objectCache[slug] = id;\n  return id;\n}\n\n// ========== PERSONS ==========\n\nasync function upsertPerson(data) {\n  console.log('üîÑ Upserting person:', data.name);\n  \n  // First, try to find existing person\n  const existingPerson = await queryPersonByName(data.name);\n  \n  if (existingPerson) {\n    console.log('üë§ Found existing person, updating:', existingPerson.id.record_id);\n    return await updatePerson(existingPerson.id.record_id, data);\n  } else {\n    console.log('üë§ Creating new person:', data.name);\n    return await createPerson(data);\n  }\n}\n\nasync function createPerson(data) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  const fullName = `${data.first_name || \"\"} ${data.last_name || \"\"}`.trim();\n\n  const values = {\n    [ATTRIBUTE_IDS.name]: [{\n      first_name: data.first_name || \"Unknown\",\n      last_name: data.last_name || \"\",\n      full_name: fullName\n    }]\n  };\n\n  // Add email if provided\n  if (data.email && ATTRIBUTE_IDS.email) {\n    values[ATTRIBUTE_IDS.email] = [{ email_address: data.email }];\n  }\n\n  // Add phone if provided\n  if (data.phone && ATTRIBUTE_IDS.phone) {\n    values[ATTRIBUTE_IDS.phone] = [{ phone_number: data.phone }];\n  }\n\n  // Add notes if provided\n  if (data.notes && ATTRIBUTE_IDS.notes) {\n    values[ATTRIBUTE_IDS.notes] = data.notes;\n  }\n\n  const payload = JSON.stringify({ data: { values } });\n\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records`, {\n    method: \"POST\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: payload\n  });\n\n  const json = await res.json();\n  if (!res.ok) {\n    console.error(\"‚ùå Person creation error:\", json);\n    throw new Error(`Failed to create person: ${JSON.stringify(json)}`);\n  } else {\n    console.log(\"‚úÖ Person created:\", json.data?.id?.record_id);\n  }\n\n  return json.data?.id?.record_id;\n}\n\nasync function updatePerson(recordId, data) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  \n  const values = {};\n  \n  // Update name if provided\n  if (data.first_name || data.last_name) {\n    const fullName = `${data.first_name || \"\"} ${data.last_name || \"\"}`.trim();\n    values[ATTRIBUTE_IDS.name] = [{\n      first_name: data.first_name || \"Unknown\",\n      last_name: data.last_name || \"\",\n      full_name: fullName\n    }];\n  }\n\n  // Update email if provided\n  if (data.email && ATTRIBUTE_IDS.email) {\n    values[ATTRIBUTE_IDS.email] = [{ email_address: data.email }];\n  }\n\n  // Update phone if provided\n  if (data.phone && ATTRIBUTE_IDS.phone) {\n    values[ATTRIBUTE_IDS.phone] = [{ phone_number: data.phone }];\n  }\n\n  // Update notes if provided (append to existing notes)\n  if (data.notes && ATTRIBUTE_IDS.notes) {\n    values[ATTRIBUTE_IDS.notes] = data.notes;\n  }\n\n  if (Object.keys(values).length === 0) {\n    console.log('‚ÑπÔ∏è No updates needed for person');\n    return recordId;\n  }\n\n  const payload = JSON.stringify({ data: { values } });\n\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records/${recordId}`, {\n    method: \"PATCH\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: payload\n  });\n\n  const json = await res.json();\n  if (!res.ok) {\n    console.error(\"‚ùå Person update error:\", json);\n    throw new Error(`Failed to update person: ${JSON.stringify(json)}`);\n  } else {\n    console.log(\"‚úÖ Person updated:\", recordId);\n  }\n\n  return recordId;\n}\n\nasync function queryPersonByName(name) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n\n  // Try exact match first\n  let payload = {\n    filter: {\n      and: [{\n        attribute: ATTRIBUTE_IDS.name,\n        query: name\n      }]\n    },\n    limit: 1\n  };\n\n  let res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records/query`, {\n    method: \"POST\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n\n  let json = await res.json();\n  \n  if (json.data && json.data.length > 0) {\n    return json.data[0];\n  }\n\n  // Try fuzzy search if exact match fails\n  const [firstName, lastName] = name.split(\" \");\n  if (firstName) {\n    payload = {\n      filter: {\n        and: [{\n          attribute: ATTRIBUTE_IDS.name,\n          query: firstName\n        }]\n      },\n      limit: 5\n    };\n\n    res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records/query`, {\n      method: \"POST\",\n      headers: {\n        Authorization: BEARER_TOKEN,\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(payload)\n    });\n\n    json = await res.json();\n    \n    // Look for best match\n    if (json.data && json.data.length > 0) {\n      for (const person of json.data) {\n        const personName = person.values[ATTRIBUTE_IDS.name]?.[0]?.full_name?.toLowerCase();\n        if (personName?.includes(name.toLowerCase())) {\n          return person;\n        }\n      }\n    }\n  }\n\n  return null;\n}\n\n// ========== TASKS ==========\n\nasync function upsertTask(data, linkedPersonId = null) {\n  console.log('üìã Creating task:', data.description);\n  \n  const taskContent = data.description;\n  \n  const payload = {\n    data: {\n      content: taskContent,\n      format: \"plaintext\",\n      deadline_at: data.due_date,\n      is_completed: false,\n      assignees: []\n    }\n  };\n\n  // Link to person if we have an ID\n  if (linkedPersonId) {\n    payload.data.linked_records = [{\n      target_object: \"people\",\n      target_record_id: linkedPersonId\n    }];\n  }\n\n  console.log(\"üì¶ Task payload:\", JSON.stringify(payload, null, 2));\n\n  const res = await fetch(`${ATTIO_API_BASE}/tasks`, {\n    method: \"POST\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n\n  const json = await res.json();\n  if (res.ok) {\n    console.log(\"‚úÖ Task created:\", json.data?.id);\n    return json.data?.id;\n  } else {\n    console.error(\"‚ùå Task creation failed:\", json);\n    throw new Error(`Failed to create task: ${JSON.stringify(json)}`);\n  }\n}\n\n// ========== UTILITY FUNCTIONS ==========\n\nasync function getAttributeIds(objectSlug) {\n  if (attributeCache[objectSlug]) return attributeCache[objectSlug];\n\n  const objectId = await getObjectIdBySlug(objectSlug);\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${objectId}/attributes`, {\n    headers: { Authorization: BEARER_TOKEN }\n  });\n\n  const json = await res.json();\n  const attributes = {};\n  \n  if (json.data) {\n    json.data.forEach(attr => {\n      attributes[attr.api_slug] = attr.id.attribute_id;\n    });\n  }\n\n  attributeCache[objectSlug] = attributes;\n  console.log(`üìã Cached attributes for ${objectSlug}:`, attributes);\n  return attributes;\n}\n\n// Call this once to populate your attribute IDs\nasync function initializeAttributeIds() {\n  try {\n    const peopleAttributes = await getAttributeIds('people');\n    console.log('People attributes:', peopleAttributes);\n    \n    // Update ATTRIBUTE_IDS with actual values\n    ATTRIBUTE_IDS.email = peopleAttributes.email_addresses;\n    ATTRIBUTE_IDS.phone = peopleAttributes.phone_numbers;\n    ATTRIBUTE_IDS.notes = peopleAttributes.notes;\n    \n    console.log('‚úÖ Attribute IDs initialized');\n  } catch (err) {\n    console.error('‚ùå Failed to initialize attribute IDs:', err);\n  }\n}\n\nexport { sendToAttio, initializeAttributeIds };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}