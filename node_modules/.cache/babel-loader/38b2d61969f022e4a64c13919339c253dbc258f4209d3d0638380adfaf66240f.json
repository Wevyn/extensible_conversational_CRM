{"ast":null,"code":"// attio.js\nconst ATTIO_API_BASE = \"https://api.attio.com/v2\";\nconst BEARER_TOKEN = \"Bearer e01cca9d5d70d62535755e3f1609118082790728f8c98dbd0b3f9cce1aae3f53\"; // replace in .env or securely\n\nconst PEOPLE_OBJECT_ID = \"3a190831-e061-4b7f-af02-644a2ff25c04\"; // Replace dynamically later\n\n// Main dispatcher\nasync function sendToAttio(structuredUpdates) {\n  for (const item of structuredUpdates) {\n    try {\n      ensureFields(item); // ✅ make sure all required keys exist\n\n      switch (item.type) {\n        case \"person\":\n          await upsertPerson(item);\n          break;\n        case \"task\":\n          await createTask(item);\n          break;\n        default:\n          console.warn(\"❓ Unhandled item type:\", item);\n      }\n    } catch (err) {\n      console.error(\"❌ Failed to send item:\", item, err);\n    }\n  }\n}\n\n// Ensure required fields are present for parsing/posting\nfunction ensureFields(item) {\n  if (item.type === \"person\") {\n    item.name = item.name || \"Unknown\";\n    item.notes = item.notes || \"\";\n  }\n  if (item.type === \"task\") {\n    item.description = item.description || \"Untitled task\";\n    item.due_date = parseDateTime(item.due_date, item.due_time);\n    item.linked_records = item.linked_records || [];\n    item.assignees = item.assignees || [];\n  }\n}\n\n// Parse flexible time expressions like \"tomorrow\", \"3:00 p.m.\"\nfunction parseDateTime(dueDate, dueTime) {\n  try {\n    let date = new Date();\n    if (dueDate !== null && dueDate !== void 0 && dueDate.toLowerCase().includes(\"tomorrow\")) {\n      date.setDate(date.getDate() + 1);\n    } else {\n      const parsed = new Date(dueDate);\n      if (!isNaN(parsed)) date = parsed;\n    }\n    if (dueTime) {\n      const [timePart, meridian] = dueTime.split(' ');\n      let [hour, minute] = timePart.split(':').map(Number);\n      if (meridian !== null && meridian !== void 0 && meridian.toLowerCase().includes('p') && hour < 12) hour += 12;\n      if (meridian !== null && meridian !== void 0 && meridian.toLowerCase().includes('a') && hour === 12) hour = 0;\n      date.setHours(hour || 0, minute || 0, 0, 0);\n    }\n    return date.toISOString();\n  } catch (err) {\n    console.warn('⚠️ Failed to parse datetime:', dueDate, dueTime, err);\n    return new Date().toISOString();\n  }\n}\nasync function upsertPerson(data) {\n  const [firstName, ...rest] = data.name.split(\" \");\n  const lastName = rest.join(\" \");\n  const payload = {\n    data: {\n      properties: {\n        first_name: firstName,\n        last_name: lastName,\n        notes: data.notes || \"\"\n      }\n    }\n  };\n  const response = await fetch(`${ATTIO_API_BASE}/objects/${PEOPLE_OBJECT_ID}/records`, {\n    method: \"POST\",\n    headers: {\n      \"Authorization\": BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n  const result = await response.json();\n  if (response.ok) {\n    var _result$data;\n    console.log(\"✅ Created/Updated Person:\", result);\n    return (_result$data = result.data) === null || _result$data === void 0 ? void 0 : _result$data.id;\n  } else {\n    console.error(\"❌ Person create error:\", result);\n    return null;\n  }\n}\nasync function createTask(data) {\n  // Optional: Link to person if given\n  let personRecordId = null;\n  if (data.link_to_person_name) {\n    personRecordId = await findPersonRecordIdByName(data.link_to_person_name);\n  }\n  const payload = {\n    data: {\n      content: data.description,\n      format: 'plaintext',\n      deadline_at: data.due_date,\n      is_completed: false,\n      linked_records: personRecordId ? [{\n        target_object: \"people\",\n        target_record_id: personRecordId\n      }] : [],\n      assignees: [] // optional\n    }\n  };\n  const response = await fetch(`${ATTIO_API_BASE}/tasks`, {\n    method: \"POST\",\n    headers: {\n      \"Authorization\": BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n  const result = await response.json();\n  if (response.ok) {\n    console.log(\"✅ Task created:\", result);\n  } else {\n    console.error(\"❌ Task creation failed:\", result);\n  }\n}\nasync function findPersonRecordIdByName(name) {\n  const response = await fetch(`${ATTIO_API_BASE}/objects/${PEOPLE_OBJECT_ID}/records`, {\n    method: \"GET\",\n    headers: {\n      \"Authorization\": BEARER_TOKEN\n    }\n  });\n  const json = await response.json();\n  const match = json.data.find(entry => {\n    var _entry$properties, _entry$properties2;\n    const fullName = `${((_entry$properties = entry.properties) === null || _entry$properties === void 0 ? void 0 : _entry$properties.first_name) || \"\"} ${((_entry$properties2 = entry.properties) === null || _entry$properties2 === void 0 ? void 0 : _entry$properties2.last_name) || \"\"}`.trim();\n    return fullName.toLowerCase() === name.toLowerCase();\n  });\n  return (match === null || match === void 0 ? void 0 : match.id) || null;\n}\nexport { sendToAttio };","map":{"version":3,"names":["ATTIO_API_BASE","BEARER_TOKEN","PEOPLE_OBJECT_ID","sendToAttio","structuredUpdates","item","ensureFields","type","upsertPerson","createTask","console","warn","err","error","name","notes","description","due_date","parseDateTime","due_time","linked_records","assignees","dueDate","dueTime","date","Date","toLowerCase","includes","setDate","getDate","parsed","isNaN","timePart","meridian","split","hour","minute","map","Number","setHours","toISOString","data","firstName","rest","lastName","join","payload","properties","first_name","last_name","response","fetch","method","headers","body","JSON","stringify","result","json","ok","_result$data","log","id","personRecordId","link_to_person_name","findPersonRecordIdByName","content","format","deadline_at","is_completed","target_object","target_record_id","match","find","entry","_entry$properties","_entry$properties2","fullName","trim"],"sources":["/Users/Aditya/ConversationalAI_CRM_Attio/src/attio.js"],"sourcesContent":["// attio.js\nconst ATTIO_API_BASE = \"https://api.attio.com/v2\";\nconst BEARER_TOKEN = \"Bearer e01cca9d5d70d62535755e3f1609118082790728f8c98dbd0b3f9cce1aae3f53\"; // replace in .env or securely\n\n\nconst PEOPLE_OBJECT_ID = \"3a190831-e061-4b7f-af02-644a2ff25c04\"; // Replace dynamically later\n\n// Main dispatcher\nasync function sendToAttio(structuredUpdates) {\n  for (const item of structuredUpdates) {\n    try {\n      ensureFields(item); // ✅ make sure all required keys exist\n\n      switch (item.type) {\n        case \"person\":\n          await upsertPerson(item);\n          break;\n        case \"task\":\n          await createTask(item);\n          break;\n        default:\n          console.warn(\"❓ Unhandled item type:\", item);\n      }\n    } catch (err) {\n      console.error(\"❌ Failed to send item:\", item, err);\n    }\n  }\n}\n\n// Ensure required fields are present for parsing/posting\nfunction ensureFields(item) {\n  if (item.type === \"person\") {\n    item.name = item.name || \"Unknown\";\n    item.notes = item.notes || \"\";\n  }\n\n  if (item.type === \"task\") {\n    item.description = item.description || \"Untitled task\";\n    item.due_date = parseDateTime(item.due_date, item.due_time);\n    item.linked_records = item.linked_records || [];\n    item.assignees = item.assignees || [];\n  }\n}\n\n// Parse flexible time expressions like \"tomorrow\", \"3:00 p.m.\"\nfunction parseDateTime(dueDate, dueTime) {\n  try {\n    let date = new Date();\n    if (dueDate?.toLowerCase().includes(\"tomorrow\")) {\n      date.setDate(date.getDate() + 1);\n    } else {\n      const parsed = new Date(dueDate);\n      if (!isNaN(parsed)) date = parsed;\n    }\n\n    if (dueTime) {\n      const [timePart, meridian] = dueTime.split(' ');\n      let [hour, minute] = timePart.split(':').map(Number);\n      if (meridian?.toLowerCase().includes('p') && hour < 12) hour += 12;\n      if (meridian?.toLowerCase().includes('a') && hour === 12) hour = 0;\n      date.setHours(hour || 0, minute || 0, 0, 0);\n    }\n\n    return date.toISOString();\n  } catch (err) {\n    console.warn('⚠️ Failed to parse datetime:', dueDate, dueTime, err);\n    return new Date().toISOString();\n  }\n}\n\nasync function upsertPerson(data) {\n  const [firstName, ...rest] = data.name.split(\" \");\n  const lastName = rest.join(\" \");\n\n  const payload = {\n    data: {\n      properties: {\n        first_name: firstName,\n        last_name: lastName,\n        notes: data.notes || \"\",\n      }\n    }\n  };\n\n  const response = await fetch(`${ATTIO_API_BASE}/objects/${PEOPLE_OBJECT_ID}/records`, {\n    method: \"POST\",\n    headers: {\n      \"Authorization\": BEARER_TOKEN,\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(payload),\n  });\n\n  const result = await response.json();\n  if (response.ok) {\n    console.log(\"✅ Created/Updated Person:\", result);\n    return result.data?.id;\n  } else {\n    console.error(\"❌ Person create error:\", result);\n    return null;\n  }\n}\n\nasync function createTask(data) {\n  // Optional: Link to person if given\n  let personRecordId = null;\n  if (data.link_to_person_name) {\n    personRecordId = await findPersonRecordIdByName(data.link_to_person_name);\n  }\n\n  const payload = {\n    data: {\n      content: data.description,\n      format: 'plaintext',\n      deadline_at: data.due_date,\n      is_completed: false,\n      linked_records: personRecordId ? [\n        { target_object: \"people\", target_record_id: personRecordId }\n      ] : [],\n      assignees: [] // optional\n    }\n  };\n\n  const response = await fetch(`${ATTIO_API_BASE}/tasks`, {\n    method: \"POST\",\n    headers: {\n      \"Authorization\": BEARER_TOKEN,\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(payload),\n  });\n\n  const result = await response.json();\n  if (response.ok) {\n    console.log(\"✅ Task created:\", result);\n  } else {\n    console.error(\"❌ Task creation failed:\", result);\n  }\n}\n\nasync function findPersonRecordIdByName(name) {\n  const response = await fetch(`${ATTIO_API_BASE}/objects/${PEOPLE_OBJECT_ID}/records`, {\n    method: \"GET\",\n    headers: { \"Authorization\": BEARER_TOKEN }\n  });\n\n  const json = await response.json();\n  const match = json.data.find(entry => {\n    const fullName = `${entry.properties?.first_name || \"\"} ${entry.properties?.last_name || \"\"}`.trim();\n    return fullName.toLowerCase() === name.toLowerCase();\n  });\n\n  return match?.id || null;\n}\n\nexport { sendToAttio };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}