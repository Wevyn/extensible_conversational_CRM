{"ast":null,"code":"// attio.js\nconst ATTIO_API_BASE = \"https://api.attio.com/v2\";\nconst BEARER_TOKEN = \"Bearer e01cca9d5d70d62535755e3f1609118082790728f8c98dbd0b3f9cce1aae3f53\";\nconst objectCache = {}; // caches object_ids like \"people\"\nconst attributeCache = {}; // caches attribute mappings\n\n// You'll need to get these from your Attio workspace\nconst ATTRIBUTE_IDS = {\n  name: \"3a2d79ac-1c54-4d1d-9bd1-df92ba80052f\",\n  email: \"4ab52dd0-edfe-4eea-b73c-561028076ea6\",\n  // You'll need to find this ID\n  phone: \"57e614f6-a910-4df8-a7a5-f175d85a8825\",\n  // You'll need to find this ID\n  notes: \"168ddd0a-6dc6-4aff-8939-60dcfe1cdf41\" // You'll need to find this ID\n};\nasync function sendToAttio(updates) {\n  console.log('üîÑ Processing updates:', updates);\n\n  // Group updates by person to handle linking\n  const personUpdates = updates.filter(item => item.type === \"person\");\n  const taskUpdates = updates.filter(item => item.type === \"task\");\n  const processedPersons = {};\n\n  // Process persons first\n  for (const item of personUpdates) {\n    try {\n      ensureFields(item);\n      const personId = await upsertPerson(item);\n      processedPersons[item.name] = personId;\n    } catch (err) {\n      console.error(\"‚ùå Failed to process person:\", item, err);\n    }\n  }\n\n  // Process tasks and link to persons\n  for (const item of taskUpdates) {\n    try {\n      ensureFields(item);\n\n      // Find the person to link to\n      let linkedPersonId = null;\n      if (item.link_to_person_name) {\n        linkedPersonId = processedPersons[item.link_to_person_name];\n        if (!linkedPersonId) {\n          var _existingPerson$id;\n          // Try to find existing person\n          const existingPerson = await queryPersonByName(item.link_to_person_name);\n          linkedPersonId = existingPerson === null || existingPerson === void 0 ? void 0 : (_existingPerson$id = existingPerson.id) === null || _existingPerson$id === void 0 ? void 0 : _existingPerson$id.record_id;\n        }\n      }\n      await upsertTask(item, linkedPersonId);\n    } catch (err) {\n      console.error(\"‚ùå Failed to process task:\", item, err);\n    }\n  }\n}\nfunction ensureFields(item) {\n  if (item.type === \"person\") {\n    item.name = item.name || \"Unknown\";\n    item.notes = item.notes || \"\";\n    const [first, ...rest] = item.name.split(\" \");\n    item.first_name = item.first_name || first || \"Unknown\";\n    item.last_name = item.last_name || rest.join(\" \") || \"\";\n  }\n  if (item.type === \"task\") {\n    item.description = item.description || item.name || \"Untitled task\";\n    item.due_date = parseDateTime(item.due_date, item.due_time);\n  }\n}\nfunction parseDateTime(date, time) {\n  try {\n    let d = new Date();\n    if (date !== null && date !== void 0 && date.toLowerCase().includes(\"tomorrow\")) {\n      d.setDate(d.getDate() + 1);\n    } else if (date !== null && date !== void 0 && date.toLowerCase().includes(\"next week\")) {\n      d.setDate(d.getDate() + 7);\n    } else if (Date.parse(date)) {\n      d = new Date(date);\n    }\n    if (time) {\n      const [t, mer] = time.split(\" \");\n      let [h, m] = t.split(\":\").map(Number);\n      if (mer !== null && mer !== void 0 && mer.includes(\"p\") && h < 12) h += 12;\n      if (mer !== null && mer !== void 0 && mer.includes(\"a\") && h === 12) h = 0;\n      d.setHours(h || 0, m || 0, 0, 0);\n    }\n    return d.toISOString();\n  } catch {\n    // Default to next week\n    const nextWeek = new Date();\n    nextWeek.setDate(nextWeek.getDate() + 7);\n    return nextWeek.toISOString();\n  }\n}\nasync function getObjectIdBySlug(slug) {\n  var _json$data, _json$data$id;\n  if (objectCache[slug]) return objectCache[slug];\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${slug}`, {\n    headers: {\n      Authorization: BEARER_TOKEN\n    }\n  });\n  if (!res.ok) {\n    throw new Error(`Failed to get object ${slug}: ${res.status}`);\n  }\n  const json = await res.json();\n  const id = (_json$data = json.data) === null || _json$data === void 0 ? void 0 : (_json$data$id = _json$data.id) === null || _json$data$id === void 0 ? void 0 : _json$data$id.object_id;\n  if (!id) throw new Error(`‚ùå Cannot resolve object slug: ${slug}`);\n  objectCache[slug] = id;\n  return id;\n}\n\n// ========== PERSONS ==========\n\nasync function upsertPerson(data) {\n  console.log('üîÑ Upserting person:', data.name);\n\n  // First, try to find existing person\n  const existingPerson = await queryPersonByName(data.name);\n  if (existingPerson) {\n    console.log('üë§ Found existing person, updating:', existingPerson.id.record_id);\n    const updatedId = await updatePerson(existingPerson.id.record_id, data, existingPerson);\n    return updatedId;\n  } else {\n    console.log('üë§ Creating new person:', data.name);\n    return await createPerson(data);\n  }\n}\nasync function createPerson(data) {\n  var _json$data3, _json$data3$id;\n  const peopleId = await getObjectIdBySlug(\"people\");\n  const fullName = `${data.first_name || \"\"} ${data.last_name || \"\"}`.trim();\n  const values = {\n    [ATTRIBUTE_IDS.name]: [{\n      first_name: data.first_name || \"Unknown\",\n      last_name: data.last_name || \"\",\n      full_name: fullName\n    }]\n  };\n\n  // Add email if provided\n  if (data.email && ATTRIBUTE_IDS.email) {\n    values[ATTRIBUTE_IDS.email] = [{\n      email_address: data.email\n    }];\n  }\n\n  // Add phone if provided\n  if (data.phone && ATTRIBUTE_IDS.phone) {\n    values[ATTRIBUTE_IDS.phone] = [{\n      phone_number: data.phone\n    }];\n  }\n\n  // Add notes if provided\n  if (data.notes && ATTRIBUTE_IDS.notes) {\n    values[ATTRIBUTE_IDS.notes] = data.notes;\n  }\n  const payload = JSON.stringify({\n    data: {\n      values\n    }\n  });\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records`, {\n    method: \"POST\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: payload\n  });\n  const json = await res.json();\n  if (!res.ok) {\n    console.error(\"‚ùå Person creation error:\", json);\n    throw new Error(`Failed to create person: ${JSON.stringify(json)}`);\n  } else {\n    var _json$data2, _json$data2$id;\n    console.log(\"‚úÖ Person created:\", (_json$data2 = json.data) === null || _json$data2 === void 0 ? void 0 : (_json$data2$id = _json$data2.id) === null || _json$data2$id === void 0 ? void 0 : _json$data2$id.record_id);\n  }\n  return (_json$data3 = json.data) === null || _json$data3 === void 0 ? void 0 : (_json$data3$id = _json$data3.id) === null || _json$data3$id === void 0 ? void 0 : _json$data3$id.record_id;\n}\nasync function updatePerson(recordId, data, existingPerson = null) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  console.log('üìù Updating person with data:', data);\n  console.log('üìã Existing person data:', existingPerson === null || existingPerson === void 0 ? void 0 : existingPerson.values);\n  const values = {};\n\n  // Only update name if it's different or if we're adding missing parts\n  if (data.first_name || data.last_name) {\n    var _existingPerson$value;\n    const existingName = existingPerson === null || existingPerson === void 0 ? void 0 : (_existingPerson$value = existingPerson.values[ATTRIBUTE_IDS.name]) === null || _existingPerson$value === void 0 ? void 0 : _existingPerson$value[0];\n    const currentFirstName = (existingName === null || existingName === void 0 ? void 0 : existingName.first_name) || '';\n    const currentLastName = (existingName === null || existingName === void 0 ? void 0 : existingName.last_name) || '';\n\n    // Use existing name parts if new ones aren't provided\n    const newFirstName = data.first_name || currentFirstName || 'Unknown';\n    const newLastName = data.last_name || currentLastName || '';\n    const fullName = `${newFirstName} ${newLastName}`.trim();\n\n    // Only update if there's actually a change\n    if (newFirstName !== currentFirstName || newLastName !== currentLastName) {\n      values[ATTRIBUTE_IDS.name] = [{\n        first_name: newFirstName,\n        last_name: newLastName,\n        full_name: fullName\n      }];\n      console.log('üìù Updating name from:', `\"${currentFirstName} ${currentLastName}\"`, 'to:', `\"${newFirstName} ${newLastName}\"`);\n    }\n  }\n\n  // Update email if provided and different\n  if (data.email && ATTRIBUTE_IDS.email) {\n    const existingEmails = (existingPerson === null || existingPerson === void 0 ? void 0 : existingPerson.values[ATTRIBUTE_IDS.email]) || [];\n    const hasEmail = existingEmails.some(e => e.email_address === data.email);\n    if (!hasEmail) {\n      // Add new email to existing emails (don't replace)\n      values[ATTRIBUTE_IDS.email] = [...existingEmails, {\n        email_address: data.email\n      }];\n      console.log('üìß Adding email:', data.email);\n    } else {\n      console.log('üìß Email already exists:', data.email);\n    }\n  }\n\n  // Update phone if provided and different\n  if (data.phone && ATTRIBUTE_IDS.phone) {\n    const existingPhones = (existingPerson === null || existingPerson === void 0 ? void 0 : existingPerson.values[ATTRIBUTE_IDS.phone]) || [];\n    const hasPhone = existingPhones.some(p => p.phone_number === data.phone);\n    if (!hasPhone) {\n      values[ATTRIBUTE_IDS.phone] = [...existingPhones, {\n        phone_number: data.phone\n      }];\n      console.log('üìû Adding phone:', data.phone);\n    } else {\n      console.log('üìû Phone already exists:', data.phone);\n    }\n  }\n\n  // Update notes if provided (append to existing notes)\n  if (data.notes && ATTRIBUTE_IDS.notes) {\n    const existingNotes = (existingPerson === null || existingPerson === void 0 ? void 0 : existingPerson.values[ATTRIBUTE_IDS.notes]) || '';\n    const newNotes = existingNotes ? `${existingNotes}\\n${data.notes}` : data.notes;\n    if (newNotes !== existingNotes) {\n      values[ATTRIBUTE_IDS.notes] = newNotes;\n      console.log('üìù Updating notes from:', `\"${existingNotes}\"`, 'to:', `\"${newNotes}\"`);\n    }\n  }\n  if (Object.keys(values).length === 0) {\n    console.log('‚ÑπÔ∏è No updates needed for person - all fields are the same');\n    return recordId;\n  }\n  console.log('üì¶ Update payload:', JSON.stringify(values, null, 2));\n  const payload = JSON.stringify({\n    data: {\n      values\n    }\n  });\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records/${recordId}`, {\n    method: \"PATCH\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: payload\n  });\n  const json = await res.json();\n  if (!res.ok) {\n    console.error(\"‚ùå Person update error:\", json);\n    throw new Error(`Failed to update person: ${JSON.stringify(json)}`);\n  } else {\n    console.log(\"‚úÖ Person updated successfully:\", recordId);\n  }\n  return recordId;\n}\nasync function queryPersonByName(name) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  console.log(`üîç Searching for person: \"${name}\"`);\n\n  // First, get all people and search through them\n  // This is more reliable than Attio's query filtering which can be finicky\n  let payload = {\n    limit: 100 // Adjust based on your needs\n  };\n  let res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records`, {\n    method: \"GET\",\n    headers: {\n      Authorization: BEARER_TOKEN\n    }\n  });\n  if (!res.ok) {\n    console.error(\"‚ùå Failed to fetch people records:\", res.status);\n    return null;\n  }\n  let json = await res.json();\n  if (!json.data || json.data.length === 0) {\n    console.log(\"‚ÑπÔ∏è No people found in database\");\n    return null;\n  }\n  console.log(`üìã Found ${json.data.length} people in database`);\n\n  // Search through all people for exact and fuzzy matches\n  const searchName = name.toLowerCase().trim();\n\n  // First pass: exact full name match\n  for (const person of json.data) {\n    var _person$values$ATTRIB;\n    const personName = (_person$values$ATTRIB = person.values[ATTRIBUTE_IDS.name]) === null || _person$values$ATTRIB === void 0 ? void 0 : _person$values$ATTRIB[0];\n    if (personName) {\n      var _personName$full_name;\n      const fullName = (_personName$full_name = personName.full_name) === null || _personName$full_name === void 0 ? void 0 : _personName$full_name.toLowerCase().trim();\n      if (fullName === searchName) {\n        console.log(`‚úÖ Found exact match: \"${fullName}\" (ID: ${person.id.record_id})`);\n        return person;\n      }\n    }\n  }\n\n  // Second pass: first name + last name combination match\n  const [searchFirst, ...searchRestParts] = searchName.split(' ');\n  const searchLast = searchRestParts.join(' ');\n  for (const person of json.data) {\n    var _person$values$ATTRIB2;\n    const personName = (_person$values$ATTRIB2 = person.values[ATTRIBUTE_IDS.name]) === null || _person$values$ATTRIB2 === void 0 ? void 0 : _person$values$ATTRIB2[0];\n    if (personName) {\n      var _personName$first_nam, _personName$last_name;\n      const firstName = (_personName$first_nam = personName.first_name) === null || _personName$first_nam === void 0 ? void 0 : _personName$first_nam.toLowerCase().trim();\n      const lastName = (_personName$last_name = personName.last_name) === null || _personName$last_name === void 0 ? void 0 : _personName$last_name.toLowerCase().trim();\n      if (firstName === searchFirst && (searchLast === '' || lastName === searchLast)) {\n        console.log(`‚úÖ Found name parts match: \"${firstName} ${lastName}\" (ID: ${person.id.record_id})`);\n        return person;\n      }\n    }\n  }\n\n  // Third pass: fuzzy match (contains)\n  for (const person of json.data) {\n    var _person$values$ATTRIB3;\n    const personName = (_person$values$ATTRIB3 = person.values[ATTRIBUTE_IDS.name]) === null || _person$values$ATTRIB3 === void 0 ? void 0 : _person$values$ATTRIB3[0];\n    if (personName) {\n      var _personName$full_name2;\n      const fullName = (_personName$full_name2 = personName.full_name) === null || _personName$full_name2 === void 0 ? void 0 : _personName$full_name2.toLowerCase().trim();\n      if (fullName && (fullName.includes(searchFirst) || searchName.includes(fullName))) {\n        console.log(`‚úÖ Found fuzzy match: \"${fullName}\" (ID: ${person.id.record_id})`);\n        return person;\n      }\n    }\n  }\n  console.log(`‚ùå No match found for: \"${name}\"`);\n  return null;\n}\n\n// ========== TASKS ==========\n\nasync function upsertTask(data, linkedPersonId = null) {\n  console.log('üìã Creating task:', data.description);\n  const taskContent = data.description;\n  const payload = {\n    data: {\n      content: taskContent,\n      format: \"plaintext\",\n      deadline_at: data.due_date,\n      is_completed: false,\n      assignees: []\n    }\n  };\n\n  // Link to person if we have an ID\n  if (linkedPersonId) {\n    payload.data.linked_records = [{\n      target_object: \"people\",\n      target_record_id: linkedPersonId\n    }];\n  }\n  console.log(\"üì¶ Task payload:\", JSON.stringify(payload, null, 2));\n  const res = await fetch(`${ATTIO_API_BASE}/tasks`, {\n    method: \"POST\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n  const json = await res.json();\n  if (res.ok) {\n    var _json$data4, _json$data5;\n    console.log(\"‚úÖ Task created:\", (_json$data4 = json.data) === null || _json$data4 === void 0 ? void 0 : _json$data4.id);\n    return (_json$data5 = json.data) === null || _json$data5 === void 0 ? void 0 : _json$data5.id;\n  } else {\n    console.error(\"‚ùå Task creation failed:\", json);\n    throw new Error(`Failed to create task: ${JSON.stringify(json)}`);\n  }\n}\n\n// ========== UTILITY FUNCTIONS ==========\n\nasync function getAttributeIds(objectSlug) {\n  if (attributeCache[objectSlug]) return attributeCache[objectSlug];\n  const objectId = await getObjectIdBySlug(objectSlug);\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${objectId}/attributes`, {\n    headers: {\n      Authorization: BEARER_TOKEN\n    }\n  });\n  const json = await res.json();\n  const attributes = {};\n  if (json.data) {\n    json.data.forEach(attr => {\n      attributes[attr.api_slug] = attr.id.attribute_id;\n    });\n  }\n  attributeCache[objectSlug] = attributes;\n  console.log(`üìã Cached attributes for ${objectSlug}:`, attributes);\n  return attributes;\n}\n\n// Call this once to populate your attribute IDs\nasync function initializeAttributeIds() {\n  try {\n    const peopleAttributes = await getAttributeIds('people');\n    console.log('People attributes:', peopleAttributes);\n\n    // Update ATTRIBUTE_IDS with actual values\n    ATTRIBUTE_IDS.email = peopleAttributes.email_addresses;\n    ATTRIBUTE_IDS.phone = peopleAttributes.phone_numbers;\n    ATTRIBUTE_IDS.notes = peopleAttributes.notes;\n    console.log('‚úÖ Attribute IDs initialized');\n  } catch (err) {\n    console.error('‚ùå Failed to initialize attribute IDs:', err);\n  }\n}\nexport { sendToAttio, initializeAttributeIds };","map":{"version":3,"names":["ATTIO_API_BASE","BEARER_TOKEN","objectCache","attributeCache","ATTRIBUTE_IDS","name","email","phone","notes","sendToAttio","updates","console","log","personUpdates","filter","item","type","taskUpdates","processedPersons","ensureFields","personId","upsertPerson","err","error","linkedPersonId","link_to_person_name","_existingPerson$id","existingPerson","queryPersonByName","id","record_id","upsertTask","first","rest","split","first_name","last_name","join","description","due_date","parseDateTime","due_time","date","time","d","Date","toLowerCase","includes","setDate","getDate","parse","t","mer","h","m","map","Number","setHours","toISOString","nextWeek","getObjectIdBySlug","slug","_json$data","_json$data$id","res","fetch","headers","Authorization","ok","Error","status","json","data","object_id","updatedId","updatePerson","createPerson","_json$data3","_json$data3$id","peopleId","fullName","trim","values","full_name","email_address","phone_number","payload","JSON","stringify","method","body","_json$data2","_json$data2$id","recordId","_existingPerson$value","existingName","currentFirstName","currentLastName","newFirstName","newLastName","existingEmails","hasEmail","some","e","existingPhones","hasPhone","p","existingNotes","newNotes","Object","keys","length","limit","searchName","person","_person$values$ATTRIB","personName","_personName$full_name","searchFirst","searchRestParts","searchLast","_person$values$ATTRIB2","_personName$first_nam","_personName$last_name","firstName","lastName","_person$values$ATTRIB3","_personName$full_name2","taskContent","content","format","deadline_at","is_completed","assignees","linked_records","target_object","target_record_id","_json$data4","_json$data5","getAttributeIds","objectSlug","objectId","attributes","forEach","attr","api_slug","attribute_id","initializeAttributeIds","peopleAttributes","email_addresses","phone_numbers"],"sources":["/Users/Aditya/ConversationalAI_CRM_Attio/src/attio.js"],"sourcesContent":["// attio.js\nconst ATTIO_API_BASE = \"https://api.attio.com/v2\";\nconst BEARER_TOKEN = \"Bearer e01cca9d5d70d62535755e3f1609118082790728f8c98dbd0b3f9cce1aae3f53\";\n\nconst objectCache = {}; // caches object_ids like \"people\"\nconst attributeCache = {}; // caches attribute mappings\n\n// You'll need to get these from your Attio workspace\nconst ATTRIBUTE_IDS = {\n  name: \"3a2d79ac-1c54-4d1d-9bd1-df92ba80052f\",\n  email: \"4ab52dd0-edfe-4eea-b73c-561028076ea6\", // You'll need to find this ID\n  phone: \"57e614f6-a910-4df8-a7a5-f175d85a8825\", // You'll need to find this ID\n  notes: \"168ddd0a-6dc6-4aff-8939-60dcfe1cdf41\"  // You'll need to find this ID\n};\n\nasync function sendToAttio(updates) {\n  console.log('üîÑ Processing updates:', updates);\n  \n  // Group updates by person to handle linking\n  const personUpdates = updates.filter(item => item.type === \"person\");\n  const taskUpdates = updates.filter(item => item.type === \"task\");\n  \n  const processedPersons = {};\n  \n  // Process persons first\n  for (const item of personUpdates) {\n    try {\n      ensureFields(item);\n      const personId = await upsertPerson(item);\n      processedPersons[item.name] = personId;\n    } catch (err) {\n      console.error(\"‚ùå Failed to process person:\", item, err);\n    }\n  }\n  \n  // Process tasks and link to persons\n  for (const item of taskUpdates) {\n    try {\n      ensureFields(item);\n      \n      // Find the person to link to\n      let linkedPersonId = null;\n      if (item.link_to_person_name) {\n        linkedPersonId = processedPersons[item.link_to_person_name];\n        if (!linkedPersonId) {\n          // Try to find existing person\n          const existingPerson = await queryPersonByName(item.link_to_person_name);\n          linkedPersonId = existingPerson?.id?.record_id;\n        }\n      }\n      \n      await upsertTask(item, linkedPersonId);\n    } catch (err) {\n      console.error(\"‚ùå Failed to process task:\", item, err);\n    }\n  }\n}\n\nfunction ensureFields(item) {\n  if (item.type === \"person\") {\n    item.name = item.name || \"Unknown\";\n    item.notes = item.notes || \"\";\n\n    const [first, ...rest] = item.name.split(\" \");\n    item.first_name = item.first_name || first || \"Unknown\";\n    item.last_name = item.last_name || rest.join(\" \") || \"\";\n  }\n\n  if (item.type === \"task\") {\n    item.description = item.description || item.name || \"Untitled task\";\n    item.due_date = parseDateTime(item.due_date, item.due_time);\n  }\n}\n\nfunction parseDateTime(date, time) {\n  try {\n    let d = new Date();\n    \n    if (date?.toLowerCase().includes(\"tomorrow\")) {\n      d.setDate(d.getDate() + 1);\n    } else if (date?.toLowerCase().includes(\"next week\")) {\n      d.setDate(d.getDate() + 7);\n    } else if (Date.parse(date)) {\n      d = new Date(date);\n    }\n\n    if (time) {\n      const [t, mer] = time.split(\" \");\n      let [h, m] = t.split(\":\").map(Number);\n      if (mer?.includes(\"p\") && h < 12) h += 12;\n      if (mer?.includes(\"a\") && h === 12) h = 0;\n      d.setHours(h || 0, m || 0, 0, 0);\n    }\n\n    return d.toISOString();\n  } catch {\n    // Default to next week\n    const nextWeek = new Date();\n    nextWeek.setDate(nextWeek.getDate() + 7);\n    return nextWeek.toISOString();\n  }\n}\n\nasync function getObjectIdBySlug(slug) {\n  if (objectCache[slug]) return objectCache[slug];\n\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${slug}`, {\n    headers: { Authorization: BEARER_TOKEN }\n  });\n\n  if (!res.ok) {\n    throw new Error(`Failed to get object ${slug}: ${res.status}`);\n  }\n\n  const json = await res.json();\n  const id = json.data?.id?.object_id;\n\n  if (!id) throw new Error(`‚ùå Cannot resolve object slug: ${slug}`);\n\n  objectCache[slug] = id;\n  return id;\n}\n\n// ========== PERSONS ==========\n\nasync function upsertPerson(data) {\n  console.log('üîÑ Upserting person:', data.name);\n  \n  // First, try to find existing person\n  const existingPerson = await queryPersonByName(data.name);\n  \n  if (existingPerson) {\n    console.log('üë§ Found existing person, updating:', existingPerson.id.record_id);\n    const updatedId = await updatePerson(existingPerson.id.record_id, data, existingPerson);\n    return updatedId;\n  } else {\n    console.log('üë§ Creating new person:', data.name);\n    return await createPerson(data);\n  }\n}\n\nasync function createPerson(data) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  const fullName = `${data.first_name || \"\"} ${data.last_name || \"\"}`.trim();\n\n  const values = {\n    [ATTRIBUTE_IDS.name]: [{\n      first_name: data.first_name || \"Unknown\",\n      last_name: data.last_name || \"\",\n      full_name: fullName\n    }]\n  };\n\n  // Add email if provided\n  if (data.email && ATTRIBUTE_IDS.email) {\n    values[ATTRIBUTE_IDS.email] = [{ email_address: data.email }];\n  }\n\n  // Add phone if provided\n  if (data.phone && ATTRIBUTE_IDS.phone) {\n    values[ATTRIBUTE_IDS.phone] = [{ phone_number: data.phone }];\n  }\n\n  // Add notes if provided\n  if (data.notes && ATTRIBUTE_IDS.notes) {\n    values[ATTRIBUTE_IDS.notes] = data.notes;\n  }\n\n  const payload = JSON.stringify({ data: { values } });\n\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records`, {\n    method: \"POST\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: payload\n  });\n\n  const json = await res.json();\n  if (!res.ok) {\n    console.error(\"‚ùå Person creation error:\", json);\n    throw new Error(`Failed to create person: ${JSON.stringify(json)}`);\n  } else {\n    console.log(\"‚úÖ Person created:\", json.data?.id?.record_id);\n  }\n\n  return json.data?.id?.record_id;\n}\n\nasync function updatePerson(recordId, data, existingPerson = null) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  \n  console.log('üìù Updating person with data:', data);\n  console.log('üìã Existing person data:', existingPerson?.values);\n  \n  const values = {};\n  \n  // Only update name if it's different or if we're adding missing parts\n  if (data.first_name || data.last_name) {\n    const existingName = existingPerson?.values[ATTRIBUTE_IDS.name]?.[0];\n    const currentFirstName = existingName?.first_name || '';\n    const currentLastName = existingName?.last_name || '';\n    \n    // Use existing name parts if new ones aren't provided\n    const newFirstName = data.first_name || currentFirstName || 'Unknown';\n    const newLastName = data.last_name || currentLastName || '';\n    const fullName = `${newFirstName} ${newLastName}`.trim();\n    \n    // Only update if there's actually a change\n    if (newFirstName !== currentFirstName || newLastName !== currentLastName) {\n      values[ATTRIBUTE_IDS.name] = [{\n        first_name: newFirstName,\n        last_name: newLastName,\n        full_name: fullName\n      }];\n      console.log('üìù Updating name from:', `\"${currentFirstName} ${currentLastName}\"`, 'to:', `\"${newFirstName} ${newLastName}\"`);\n    }\n  }\n\n  // Update email if provided and different\n  if (data.email && ATTRIBUTE_IDS.email) {\n    const existingEmails = existingPerson?.values[ATTRIBUTE_IDS.email] || [];\n    const hasEmail = existingEmails.some(e => e.email_address === data.email);\n    \n    if (!hasEmail) {\n      // Add new email to existing emails (don't replace)\n      values[ATTRIBUTE_IDS.email] = [...existingEmails, { email_address: data.email }];\n      console.log('üìß Adding email:', data.email);\n    } else {\n      console.log('üìß Email already exists:', data.email);\n    }\n  }\n\n  // Update phone if provided and different\n  if (data.phone && ATTRIBUTE_IDS.phone) {\n    const existingPhones = existingPerson?.values[ATTRIBUTE_IDS.phone] || [];\n    const hasPhone = existingPhones.some(p => p.phone_number === data.phone);\n    \n    if (!hasPhone) {\n      values[ATTRIBUTE_IDS.phone] = [...existingPhones, { phone_number: data.phone }];\n      console.log('üìû Adding phone:', data.phone);\n    } else {\n      console.log('üìû Phone already exists:', data.phone);\n    }\n  }\n\n  // Update notes if provided (append to existing notes)\n  if (data.notes && ATTRIBUTE_IDS.notes) {\n    const existingNotes = existingPerson?.values[ATTRIBUTE_IDS.notes] || '';\n    const newNotes = existingNotes ? `${existingNotes}\\n${data.notes}` : data.notes;\n    \n    if (newNotes !== existingNotes) {\n      values[ATTRIBUTE_IDS.notes] = newNotes;\n      console.log('üìù Updating notes from:', `\"${existingNotes}\"`, 'to:', `\"${newNotes}\"`);\n    }\n  }\n\n  if (Object.keys(values).length === 0) {\n    console.log('‚ÑπÔ∏è No updates needed for person - all fields are the same');\n    return recordId;\n  }\n\n  console.log('üì¶ Update payload:', JSON.stringify(values, null, 2));\n\n  const payload = JSON.stringify({ data: { values } });\n\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records/${recordId}`, {\n    method: \"PATCH\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: payload\n  });\n\n  const json = await res.json();\n  if (!res.ok) {\n    console.error(\"‚ùå Person update error:\", json);\n    throw new Error(`Failed to update person: ${JSON.stringify(json)}`);\n  } else {\n    console.log(\"‚úÖ Person updated successfully:\", recordId);\n  }\n\n  return recordId;\n}\n\nasync function queryPersonByName(name) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  \n  console.log(`üîç Searching for person: \"${name}\"`);\n\n  // First, get all people and search through them\n  // This is more reliable than Attio's query filtering which can be finicky\n  let payload = {\n    limit: 100 // Adjust based on your needs\n  };\n\n  let res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records`, {\n    method: \"GET\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n    }\n  });\n\n  if (!res.ok) {\n    console.error(\"‚ùå Failed to fetch people records:\", res.status);\n    return null;\n  }\n\n  let json = await res.json();\n  \n  if (!json.data || json.data.length === 0) {\n    console.log(\"‚ÑπÔ∏è No people found in database\");\n    return null;\n  }\n\n  console.log(`üìã Found ${json.data.length} people in database`);\n\n  // Search through all people for exact and fuzzy matches\n  const searchName = name.toLowerCase().trim();\n  \n  // First pass: exact full name match\n  for (const person of json.data) {\n    const personName = person.values[ATTRIBUTE_IDS.name]?.[0];\n    if (personName) {\n      const fullName = personName.full_name?.toLowerCase().trim();\n      if (fullName === searchName) {\n        console.log(`‚úÖ Found exact match: \"${fullName}\" (ID: ${person.id.record_id})`);\n        return person;\n      }\n    }\n  }\n\n  // Second pass: first name + last name combination match\n  const [searchFirst, ...searchRestParts] = searchName.split(' ');\n  const searchLast = searchRestParts.join(' ');\n\n  for (const person of json.data) {\n    const personName = person.values[ATTRIBUTE_IDS.name]?.[0];\n    if (personName) {\n      const firstName = personName.first_name?.toLowerCase().trim();\n      const lastName = personName.last_name?.toLowerCase().trim();\n      \n      if (firstName === searchFirst && \n          (searchLast === '' || lastName === searchLast)) {\n        console.log(`‚úÖ Found name parts match: \"${firstName} ${lastName}\" (ID: ${person.id.record_id})`);\n        return person;\n      }\n    }\n  }\n\n  // Third pass: fuzzy match (contains)\n  for (const person of json.data) {\n    const personName = person.values[ATTRIBUTE_IDS.name]?.[0];\n    if (personName) {\n      const fullName = personName.full_name?.toLowerCase().trim();\n      if (fullName && (fullName.includes(searchFirst) || searchName.includes(fullName))) {\n        console.log(`‚úÖ Found fuzzy match: \"${fullName}\" (ID: ${person.id.record_id})`);\n        return person;\n      }\n    }\n  }\n\n  console.log(`‚ùå No match found for: \"${name}\"`);\n  return null;\n}\n\n// ========== TASKS ==========\n\nasync function upsertTask(data, linkedPersonId = null) {\n  console.log('üìã Creating task:', data.description);\n  \n  const taskContent = data.description;\n  \n  const payload = {\n    data: {\n      content: taskContent,\n      format: \"plaintext\",\n      deadline_at: data.due_date,\n      is_completed: false,\n      assignees: []\n    }\n  };\n\n  // Link to person if we have an ID\n  if (linkedPersonId) {\n    payload.data.linked_records = [{\n      target_object: \"people\",\n      target_record_id: linkedPersonId\n    }];\n  }\n\n  console.log(\"üì¶ Task payload:\", JSON.stringify(payload, null, 2));\n\n  const res = await fetch(`${ATTIO_API_BASE}/tasks`, {\n    method: \"POST\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n\n  const json = await res.json();\n  if (res.ok) {\n    console.log(\"‚úÖ Task created:\", json.data?.id);\n    return json.data?.id;\n  } else {\n    console.error(\"‚ùå Task creation failed:\", json);\n    throw new Error(`Failed to create task: ${JSON.stringify(json)}`);\n  }\n}\n\n// ========== UTILITY FUNCTIONS ==========\n\nasync function getAttributeIds(objectSlug) {\n  if (attributeCache[objectSlug]) return attributeCache[objectSlug];\n\n  const objectId = await getObjectIdBySlug(objectSlug);\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${objectId}/attributes`, {\n    headers: { Authorization: BEARER_TOKEN }\n  });\n\n  const json = await res.json();\n  const attributes = {};\n  \n  if (json.data) {\n    json.data.forEach(attr => {\n      attributes[attr.api_slug] = attr.id.attribute_id;\n    });\n  }\n\n  attributeCache[objectSlug] = attributes;\n  console.log(`üìã Cached attributes for ${objectSlug}:`, attributes);\n  return attributes;\n}\n\n// Call this once to populate your attribute IDs\nasync function initializeAttributeIds() {\n  try {\n    const peopleAttributes = await getAttributeIds('people');\n    console.log('People attributes:', peopleAttributes);\n    \n    // Update ATTRIBUTE_IDS with actual values\n    ATTRIBUTE_IDS.email = peopleAttributes.email_addresses;\n    ATTRIBUTE_IDS.phone = peopleAttributes.phone_numbers;\n    ATTRIBUTE_IDS.notes = peopleAttributes.notes;\n    \n    console.log('‚úÖ Attribute IDs initialized');\n  } catch (err) {\n    console.error('‚ùå Failed to initialize attribute IDs:', err);\n  }\n}\n\nexport { sendToAttio, initializeAttributeIds };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}