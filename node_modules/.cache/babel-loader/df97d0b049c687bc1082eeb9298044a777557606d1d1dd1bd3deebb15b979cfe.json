{"ast":null,"code":"// attio.js\nconst ATTIO_API_BASE = \"https://api.attio.com/v2\";\nconst BEARER_TOKEN = \"Bearer e01cca9d5d70d62535755e3f1609118082790728f8c98dbd0b3f9cce1aae3f53\";\nconst objectCache = {}; // caches object_ids like \"people\"\nconst attributeCache = {}; // caches attribute mappings\n\nasync function sendToAttio(updates) {\n  console.log('üîÑ Processing updates:', updates);\n\n  // Group updates by person to handle linking\n  const personUpdates = updates.filter(item => item.type === \"person\");\n  const taskUpdates = updates.filter(item => item.type === \"task\");\n  const processedPersons = {};\n\n  // Process persons first\n  for (const item of personUpdates) {\n    try {\n      ensureFields(item);\n      const personId = await upsertPerson(item);\n      processedPersons[item.name] = personId;\n    } catch (err) {\n      console.error(\"‚ùå Failed to process person:\", item, err);\n    }\n  }\n\n  // Process tasks and link to persons\n  for (const item of taskUpdates) {\n    try {\n      ensureFields(item);\n\n      // Find the person to link to\n      let linkedPersonId = null;\n      if (item.link_to_person_name) {\n        linkedPersonId = processedPersons[item.link_to_person_name];\n        if (!linkedPersonId) {\n          var _existingPerson$id;\n          // Try to find existing person\n          const existingPerson = await queryPersonByName(item.link_to_person_name);\n          linkedPersonId = existingPerson === null || existingPerson === void 0 ? void 0 : (_existingPerson$id = existingPerson.id) === null || _existingPerson$id === void 0 ? void 0 : _existingPerson$id.record_id;\n        }\n      }\n      await upsertTask(item, linkedPersonId);\n    } catch (err) {\n      console.error(\"‚ùå Failed to process task:\", item, err);\n    }\n  }\n}\nfunction ensureFields(item) {\n  if (item.type === \"person\") {\n    item.name = item.name || \"Unknown\";\n    item.notes = item.notes || \"\";\n    const [first, ...rest] = item.name.split(\" \");\n    item.first_name = item.first_name || first || \"Unknown\";\n    item.last_name = item.last_name || rest.join(\" \") || \"\";\n  }\n  if (item.type === \"task\") {\n    item.description = item.description || item.name || \"Untitled task\";\n    item.due_date = parseDateTime(item.due_date, item.due_time);\n  }\n}\nfunction parseDateTime(date, time) {\n  try {\n    let d = new Date();\n    if (date !== null && date !== void 0 && date.toLowerCase().includes(\"tomorrow\")) {\n      d.setDate(d.getDate() + 1);\n    } else if (date !== null && date !== void 0 && date.toLowerCase().includes(\"next week\")) {\n      d.setDate(d.getDate() + 7);\n    } else if (Date.parse(date)) {\n      d = new Date(date);\n    }\n    if (time) {\n      const [t, mer] = time.split(\" \");\n      let [h, m] = t.split(\":\").map(Number);\n      if (mer !== null && mer !== void 0 && mer.includes(\"p\") && h < 12) h += 12;\n      if (mer !== null && mer !== void 0 && mer.includes(\"a\") && h === 12) h = 0;\n      d.setHours(h || 0, m || 0, 0, 0);\n    }\n    return d.toISOString();\n  } catch {\n    // Default to next week\n    const nextWeek = new Date();\n    nextWeek.setDate(nextWeek.getDate() + 7);\n    return nextWeek.toISOString();\n  }\n}\nasync function getObjectIdBySlug(slug) {\n  var _json$data, _json$data$id;\n  if (objectCache[slug]) return objectCache[slug];\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${slug}`, {\n    headers: {\n      Authorization: BEARER_TOKEN\n    }\n  });\n  if (!res.ok) {\n    throw new Error(`Failed to get object ${slug}: ${res.status}`);\n  }\n  const json = await res.json();\n  const id = (_json$data = json.data) === null || _json$data === void 0 ? void 0 : (_json$data$id = _json$data.id) === null || _json$data$id === void 0 ? void 0 : _json$data$id.object_id;\n  if (!id) throw new Error(`‚ùå Cannot resolve object slug: ${slug}`);\n  objectCache[slug] = id;\n  return id;\n}\n\n// ========== PERSONS ==========\n\nasync function upsertPerson(data) {\n  console.log('üîÑ Upserting person:', data.name);\n\n  // First, try to find existing person\n  const existingPerson = await queryPersonByName(data.name);\n  if (existingPerson) {\n    console.log('üë§ Found existing person, updating:', existingPerson.id.record_id);\n    const updatedId = await updatePerson(existingPerson.id.record_id, data, existingPerson);\n    return updatedId;\n  } else {\n    console.log('üë§ Creating new person:', data.name);\n    return await createPerson(data);\n  }\n}\nasync function createPerson(data) {\n  var _json$data3, _json$data3$id;\n  const peopleId = await getObjectIdBySlug(\"people\");\n  const fullName = `${data.first_name || \"\"} ${data.last_name || \"\"}`.trim();\n  const values = {\n    [ATTRIBUTE_IDS.name]: [{\n      first_name: data.first_name || \"Unknown\",\n      last_name: data.last_name || \"\",\n      full_name: fullName\n    }]\n  };\n\n  // Add email if provided\n  if (data.email && ATTRIBUTE_IDS.email) {\n    values[ATTRIBUTE_IDS.email] = [{\n      email_address: data.email\n    }];\n  }\n\n  // Add phone if provided\n  if (data.phone && ATTRIBUTE_IDS.phone) {\n    values[ATTRIBUTE_IDS.phone] = [{\n      phone_number: data.phone\n    }];\n  }\n\n  // Add notes if provided\n  if (data.notes && ATTRIBUTE_IDS.notes) {\n    values[ATTRIBUTE_IDS.notes] = data.notes;\n  }\n  const payload = JSON.stringify({\n    data: {\n      values\n    }\n  });\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records`, {\n    method: \"POST\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: payload\n  });\n  const json = await res.json();\n  if (!res.ok) {\n    console.error(\"‚ùå Person creation error:\", json);\n    throw new Error(`Failed to create person: ${JSON.stringify(json)}`);\n  } else {\n    var _json$data2, _json$data2$id;\n    console.log(\"‚úÖ Person created:\", (_json$data2 = json.data) === null || _json$data2 === void 0 ? void 0 : (_json$data2$id = _json$data2.id) === null || _json$data2$id === void 0 ? void 0 : _json$data2$id.record_id);\n  }\n  return (_json$data3 = json.data) === null || _json$data3 === void 0 ? void 0 : (_json$data3$id = _json$data3.id) === null || _json$data3$id === void 0 ? void 0 : _json$data3$id.record_id;\n}\nasync function updatePerson(recordId, data, existingPerson = null) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  console.log('üìù Updating person with data:', data);\n  console.log('üìã Existing person data:', existingPerson === null || existingPerson === void 0 ? void 0 : existingPerson.values);\n  const values = {};\n\n  // Only update name if it's different or if we're adding missing parts\n  if (data.first_name || data.last_name) {\n    var _existingPerson$value;\n    const existingName = existingPerson === null || existingPerson === void 0 ? void 0 : (_existingPerson$value = existingPerson.values[ATTRIBUTE_IDS.name]) === null || _existingPerson$value === void 0 ? void 0 : _existingPerson$value[0];\n    const currentFirstName = (existingName === null || existingName === void 0 ? void 0 : existingName.first_name) || '';\n    const currentLastName = (existingName === null || existingName === void 0 ? void 0 : existingName.last_name) || '';\n\n    // Use existing name parts if new ones aren't provided\n    const newFirstName = data.first_name || currentFirstName || 'Unknown';\n    const newLastName = data.last_name || currentLastName || '';\n    const fullName = `${newFirstName} ${newLastName}`.trim();\n\n    // Only update if there's actually a change\n    if (newFirstName !== currentFirstName || newLastName !== currentLastName) {\n      values[ATTRIBUTE_IDS.name] = [{\n        first_name: newFirstName,\n        last_name: newLastName,\n        full_name: fullName\n      }];\n      console.log('üìù Updating name from:', `\"${currentFirstName} ${currentLastName}\"`, 'to:', `\"${newFirstName} ${newLastName}\"`);\n    }\n  }\n\n  // Update email if provided and different\n  if (data.email && ATTRIBUTE_IDS.email) {\n    const existingEmails = (existingPerson === null || existingPerson === void 0 ? void 0 : existingPerson.values[ATTRIBUTE_IDS.email]) || [];\n    const hasEmail = existingEmails.some(e => e.email_address === data.email);\n    if (!hasEmail) {\n      // Add new email to existing emails (don't replace)\n      values[ATTRIBUTE_IDS.email] = [...existingEmails, {\n        email_address: data.email\n      }];\n      console.log('üìß Adding email:', data.email);\n    } else {\n      console.log('üìß Email already exists:', data.email);\n    }\n  }\n\n  // Update phone if provided and different\n  if (data.phone && ATTRIBUTE_IDS.phone) {\n    const existingPhones = (existingPerson === null || existingPerson === void 0 ? void 0 : existingPerson.values[ATTRIBUTE_IDS.phone]) || [];\n    const hasPhone = existingPhones.some(p => p.phone_number === data.phone);\n    if (!hasPhone) {\n      values[ATTRIBUTE_IDS.phone] = [...existingPhones, {\n        phone_number: data.phone\n      }];\n      console.log('üìû Adding phone:', data.phone);\n    } else {\n      console.log('üìû Phone already exists:', data.phone);\n    }\n  }\n\n  // Update notes if provided (append to existing notes)\n  if (data.notes && ATTRIBUTE_IDS.notes) {\n    const existingNotes = (existingPerson === null || existingPerson === void 0 ? void 0 : existingPerson.values[ATTRIBUTE_IDS.notes]) || '';\n    const newNotes = existingNotes ? `${existingNotes}\\n${data.notes}` : data.notes;\n    if (newNotes !== existingNotes) {\n      values[ATTRIBUTE_IDS.notes] = newNotes;\n      console.log('üìù Updating notes from:', `\"${existingNotes}\"`, 'to:', `\"${newNotes}\"`);\n    }\n  }\n  if (Object.keys(values).length === 0) {\n    console.log('‚ÑπÔ∏è No updates needed for person - all fields are the same');\n    return recordId;\n  }\n  console.log('üì¶ Update payload:', JSON.stringify(values, null, 2));\n  const payload = JSON.stringify({\n    data: {\n      values\n    }\n  });\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records/${recordId}`, {\n    method: \"PATCH\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: payload\n  });\n  const json = await res.json();\n  if (!res.ok) {\n    console.error(\"‚ùå Person update error:\", json);\n    throw new Error(`Failed to update person: ${JSON.stringify(json)}`);\n  } else {\n    console.log(\"‚úÖ Person updated successfully:\", recordId);\n  }\n  return recordId;\n}\nasync function queryPersonByName(name) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  console.log(`üîç Searching for person: \"${name}\"`);\n\n  // First, get all people and search through them\n  // This is more reliable than Attio's query filtering which can be finicky\n  let payload = {\n    limit: 100 // Adjust based on your needs\n  };\n  let res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records`, {\n    method: \"GET\",\n    headers: {\n      Authorization: BEARER_TOKEN\n    }\n  });\n  if (!res.ok) {\n    console.error(\"‚ùå Failed to fetch people records:\", res.status);\n    return null;\n  }\n  let json = await res.json();\n  if (!json.data || json.data.length === 0) {\n    console.log(\"‚ÑπÔ∏è No people found in database\");\n    return null;\n  }\n  console.log(`üìã Found ${json.data.length} people in database`);\n\n  // Search through all people for exact and fuzzy matches\n  const searchName = name.toLowerCase().trim();\n\n  // First pass: exact full name match\n  for (const person of json.data) {\n    var _person$values$ATTRIB;\n    const personName = (_person$values$ATTRIB = person.values[ATTRIBUTE_IDS.name]) === null || _person$values$ATTRIB === void 0 ? void 0 : _person$values$ATTRIB[0];\n    if (personName) {\n      var _personName$full_name;\n      const fullName = (_personName$full_name = personName.full_name) === null || _personName$full_name === void 0 ? void 0 : _personName$full_name.toLowerCase().trim();\n      if (fullName === searchName) {\n        console.log(`‚úÖ Found exact match: \"${fullName}\" (ID: ${person.id.record_id})`);\n        return person;\n      }\n    }\n  }\n\n  // Second pass: first name + last name combination match\n  const [searchFirst, ...searchRestParts] = searchName.split(' ');\n  const searchLast = searchRestParts.join(' ');\n  for (const person of json.data) {\n    var _person$values$ATTRIB2;\n    const personName = (_person$values$ATTRIB2 = person.values[ATTRIBUTE_IDS.name]) === null || _person$values$ATTRIB2 === void 0 ? void 0 : _person$values$ATTRIB2[0];\n    if (personName) {\n      var _personName$first_nam, _personName$last_name;\n      const firstName = (_personName$first_nam = personName.first_name) === null || _personName$first_nam === void 0 ? void 0 : _personName$first_nam.toLowerCase().trim();\n      const lastName = (_personName$last_name = personName.last_name) === null || _personName$last_name === void 0 ? void 0 : _personName$last_name.toLowerCase().trim();\n      if (firstName === searchFirst && (searchLast === '' || lastName === searchLast)) {\n        console.log(`‚úÖ Found name parts match: \"${firstName} ${lastName}\" (ID: ${person.id.record_id})`);\n        return person;\n      }\n    }\n  }\n\n  // Third pass: fuzzy match (contains)\n  for (const person of json.data) {\n    var _person$values$ATTRIB3;\n    const personName = (_person$values$ATTRIB3 = person.values[ATTRIBUTE_IDS.name]) === null || _person$values$ATTRIB3 === void 0 ? void 0 : _person$values$ATTRIB3[0];\n    if (personName) {\n      var _personName$full_name2;\n      const fullName = (_personName$full_name2 = personName.full_name) === null || _personName$full_name2 === void 0 ? void 0 : _personName$full_name2.toLowerCase().trim();\n      if (fullName && (fullName.includes(searchFirst) || searchName.includes(fullName))) {\n        console.log(`‚úÖ Found fuzzy match: \"${fullName}\" (ID: ${person.id.record_id})`);\n        return person;\n      }\n    }\n  }\n  console.log(`‚ùå No match found for: \"${name}\"`);\n  return null;\n}\n\n// ========== TASKS ==========\n\nasync function upsertTask(data, linkedPersonId = null) {\n  console.log('üìã Creating task:', data.description);\n  const taskContent = data.description;\n  const payload = {\n    data: {\n      content: taskContent,\n      format: \"plaintext\",\n      deadline_at: data.due_date,\n      is_completed: false,\n      assignees: []\n    }\n  };\n\n  // Link to person if we have an ID\n  if (linkedPersonId) {\n    payload.data.linked_records = [{\n      target_object: \"people\",\n      target_record_id: linkedPersonId\n    }];\n  }\n  console.log(\"üì¶ Task payload:\", JSON.stringify(payload, null, 2));\n  const res = await fetch(`${ATTIO_API_BASE}/tasks`, {\n    method: \"POST\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n  const json = await res.json();\n  if (res.ok) {\n    var _json$data4, _json$data5;\n    console.log(\"‚úÖ Task created:\", (_json$data4 = json.data) === null || _json$data4 === void 0 ? void 0 : _json$data4.id);\n    return (_json$data5 = json.data) === null || _json$data5 === void 0 ? void 0 : _json$data5.id;\n  } else {\n    console.error(\"‚ùå Task creation failed:\", json);\n    throw new Error(`Failed to create task: ${JSON.stringify(json)}`);\n  }\n}\n\n// ========== UTILITY FUNCTIONS ==========\n\nasync function getAttributeIds(objectSlug) {\n  if (attributeCache[objectSlug]) return attributeCache[objectSlug];\n  const objectId = await getObjectIdBySlug(objectSlug);\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${objectId}/attributes`, {\n    headers: {\n      Authorization: BEARER_TOKEN\n    }\n  });\n  const json = await res.json();\n  const attributes = {};\n  if (json.data) {\n    json.data.forEach(attr => {\n      attributes[attr.api_slug] = attr.id.attribute_id;\n    });\n  }\n  attributeCache[objectSlug] = attributes;\n  console.log(`üìã Cached attributes for ${objectSlug}:`, attributes);\n  return attributes;\n}\n\n// Call this once to populate your attribute IDs\nasync function initializeAttributeIds() {\n  try {\n    const peopleAttributes = await getAttributeIds('people');\n    console.log('People attributes:', peopleAttributes);\n\n    // Update ATTRIBUTE_IDS with actual values\n    ATTRIBUTE_IDS.email = peopleAttributes.email_addresses;\n    ATTRIBUTE_IDS.phone = peopleAttributes.phone_numbers;\n    ATTRIBUTE_IDS.notes = peopleAttributes.notes;\n    console.log('‚úÖ Attribute IDs initialized');\n  } catch (err) {\n    console.error('‚ùå Failed to initialize attribute IDs:', err);\n  }\n}\nexport { sendToAttio, initializeAttributeIds };","map":{"version":3,"names":["ATTIO_API_BASE","BEARER_TOKEN","objectCache","attributeCache","sendToAttio","updates","console","log","personUpdates","filter","item","type","taskUpdates","processedPersons","ensureFields","personId","upsertPerson","name","err","error","linkedPersonId","link_to_person_name","_existingPerson$id","existingPerson","queryPersonByName","id","record_id","upsertTask","notes","first","rest","split","first_name","last_name","join","description","due_date","parseDateTime","due_time","date","time","d","Date","toLowerCase","includes","setDate","getDate","parse","t","mer","h","m","map","Number","setHours","toISOString","nextWeek","getObjectIdBySlug","slug","_json$data","_json$data$id","res","fetch","headers","Authorization","ok","Error","status","json","data","object_id","updatedId","updatePerson","createPerson","_json$data3","_json$data3$id","peopleId","fullName","trim","values","ATTRIBUTE_IDS","full_name","email","email_address","phone","phone_number","payload","JSON","stringify","method","body","_json$data2","_json$data2$id","recordId","_existingPerson$value","existingName","currentFirstName","currentLastName","newFirstName","newLastName","existingEmails","hasEmail","some","e","existingPhones","hasPhone","p","existingNotes","newNotes","Object","keys","length","limit","searchName","person","_person$values$ATTRIB","personName","_personName$full_name","searchFirst","searchRestParts","searchLast","_person$values$ATTRIB2","_personName$first_nam","_personName$last_name","firstName","lastName","_person$values$ATTRIB3","_personName$full_name2","taskContent","content","format","deadline_at","is_completed","assignees","linked_records","target_object","target_record_id","_json$data4","_json$data5","getAttributeIds","objectSlug","objectId","attributes","forEach","attr","api_slug","attribute_id","initializeAttributeIds","peopleAttributes","email_addresses","phone_numbers"],"sources":["/Users/Aditya/ConversationalAI_CRM_Attio/src/attio.js"],"sourcesContent":["// attio.js\nconst ATTIO_API_BASE = \"https://api.attio.com/v2\";\nconst BEARER_TOKEN = \"Bearer e01cca9d5d70d62535755e3f1609118082790728f8c98dbd0b3f9cce1aae3f53\";\n\nconst objectCache = {}; // caches object_ids like \"people\"\nconst attributeCache = {}; // caches attribute mappings\n\nasync function sendToAttio(updates) {\n  console.log('üîÑ Processing updates:', updates);\n  \n  // Group updates by person to handle linking\n  const personUpdates = updates.filter(item => item.type === \"person\");\n  const taskUpdates = updates.filter(item => item.type === \"task\");\n  \n  const processedPersons = {};\n  \n  // Process persons first\n  for (const item of personUpdates) {\n    try {\n      ensureFields(item);\n      const personId = await upsertPerson(item);\n      processedPersons[item.name] = personId;\n    } catch (err) {\n      console.error(\"‚ùå Failed to process person:\", item, err);\n    }\n  }\n  \n  // Process tasks and link to persons\n  for (const item of taskUpdates) {\n    try {\n      ensureFields(item);\n      \n      // Find the person to link to\n      let linkedPersonId = null;\n      if (item.link_to_person_name) {\n        linkedPersonId = processedPersons[item.link_to_person_name];\n        if (!linkedPersonId) {\n          // Try to find existing person\n          const existingPerson = await queryPersonByName(item.link_to_person_name);\n          linkedPersonId = existingPerson?.id?.record_id;\n        }\n      }\n      \n      await upsertTask(item, linkedPersonId);\n    } catch (err) {\n      console.error(\"‚ùå Failed to process task:\", item, err);\n    }\n  }\n}\n\nfunction ensureFields(item) {\n  if (item.type === \"person\") {\n    item.name = item.name || \"Unknown\";\n    item.notes = item.notes || \"\";\n\n    const [first, ...rest] = item.name.split(\" \");\n    item.first_name = item.first_name || first || \"Unknown\";\n    item.last_name = item.last_name || rest.join(\" \") || \"\";\n  }\n\n  if (item.type === \"task\") {\n    item.description = item.description || item.name || \"Untitled task\";\n    item.due_date = parseDateTime(item.due_date, item.due_time);\n  }\n}\n\nfunction parseDateTime(date, time) {\n  try {\n    let d = new Date();\n    \n    if (date?.toLowerCase().includes(\"tomorrow\")) {\n      d.setDate(d.getDate() + 1);\n    } else if (date?.toLowerCase().includes(\"next week\")) {\n      d.setDate(d.getDate() + 7);\n    } else if (Date.parse(date)) {\n      d = new Date(date);\n    }\n\n    if (time) {\n      const [t, mer] = time.split(\" \");\n      let [h, m] = t.split(\":\").map(Number);\n      if (mer?.includes(\"p\") && h < 12) h += 12;\n      if (mer?.includes(\"a\") && h === 12) h = 0;\n      d.setHours(h || 0, m || 0, 0, 0);\n    }\n\n    return d.toISOString();\n  } catch {\n    // Default to next week\n    const nextWeek = new Date();\n    nextWeek.setDate(nextWeek.getDate() + 7);\n    return nextWeek.toISOString();\n  }\n}\n\nasync function getObjectIdBySlug(slug) {\n  if (objectCache[slug]) return objectCache[slug];\n\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${slug}`, {\n    headers: { Authorization: BEARER_TOKEN }\n  });\n\n  if (!res.ok) {\n    throw new Error(`Failed to get object ${slug}: ${res.status}`);\n  }\n\n  const json = await res.json();\n  const id = json.data?.id?.object_id;\n\n  if (!id) throw new Error(`‚ùå Cannot resolve object slug: ${slug}`);\n\n  objectCache[slug] = id;\n  return id;\n}\n\n// ========== PERSONS ==========\n\nasync function upsertPerson(data) {\n  console.log('üîÑ Upserting person:', data.name);\n  \n  // First, try to find existing person\n  const existingPerson = await queryPersonByName(data.name);\n  \n  if (existingPerson) {\n    console.log('üë§ Found existing person, updating:', existingPerson.id.record_id);\n    const updatedId = await updatePerson(existingPerson.id.record_id, data, existingPerson);\n    return updatedId;\n  } else {\n    console.log('üë§ Creating new person:', data.name);\n    return await createPerson(data);\n  }\n}\n\nasync function createPerson(data) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  const fullName = `${data.first_name || \"\"} ${data.last_name || \"\"}`.trim();\n\n  const values = {\n    [ATTRIBUTE_IDS.name]: [{\n      first_name: data.first_name || \"Unknown\",\n      last_name: data.last_name || \"\",\n      full_name: fullName\n    }]\n  };\n\n  // Add email if provided\n  if (data.email && ATTRIBUTE_IDS.email) {\n    values[ATTRIBUTE_IDS.email] = [{ email_address: data.email }];\n  }\n\n  // Add phone if provided\n  if (data.phone && ATTRIBUTE_IDS.phone) {\n    values[ATTRIBUTE_IDS.phone] = [{ phone_number: data.phone }];\n  }\n\n  // Add notes if provided\n  if (data.notes && ATTRIBUTE_IDS.notes) {\n    values[ATTRIBUTE_IDS.notes] = data.notes;\n  }\n\n  const payload = JSON.stringify({ data: { values } });\n\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records`, {\n    method: \"POST\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: payload\n  });\n\n  const json = await res.json();\n  if (!res.ok) {\n    console.error(\"‚ùå Person creation error:\", json);\n    throw new Error(`Failed to create person: ${JSON.stringify(json)}`);\n  } else {\n    console.log(\"‚úÖ Person created:\", json.data?.id?.record_id);\n  }\n\n  return json.data?.id?.record_id;\n}\n\nasync function updatePerson(recordId, data, existingPerson = null) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  \n  console.log('üìù Updating person with data:', data);\n  console.log('üìã Existing person data:', existingPerson?.values);\n  \n  const values = {};\n  \n  // Only update name if it's different or if we're adding missing parts\n  if (data.first_name || data.last_name) {\n    const existingName = existingPerson?.values[ATTRIBUTE_IDS.name]?.[0];\n    const currentFirstName = existingName?.first_name || '';\n    const currentLastName = existingName?.last_name || '';\n    \n    // Use existing name parts if new ones aren't provided\n    const newFirstName = data.first_name || currentFirstName || 'Unknown';\n    const newLastName = data.last_name || currentLastName || '';\n    const fullName = `${newFirstName} ${newLastName}`.trim();\n    \n    // Only update if there's actually a change\n    if (newFirstName !== currentFirstName || newLastName !== currentLastName) {\n      values[ATTRIBUTE_IDS.name] = [{\n        first_name: newFirstName,\n        last_name: newLastName,\n        full_name: fullName\n      }];\n      console.log('üìù Updating name from:', `\"${currentFirstName} ${currentLastName}\"`, 'to:', `\"${newFirstName} ${newLastName}\"`);\n    }\n  }\n\n  // Update email if provided and different\n  if (data.email && ATTRIBUTE_IDS.email) {\n    const existingEmails = existingPerson?.values[ATTRIBUTE_IDS.email] || [];\n    const hasEmail = existingEmails.some(e => e.email_address === data.email);\n    \n    if (!hasEmail) {\n      // Add new email to existing emails (don't replace)\n      values[ATTRIBUTE_IDS.email] = [...existingEmails, { email_address: data.email }];\n      console.log('üìß Adding email:', data.email);\n    } else {\n      console.log('üìß Email already exists:', data.email);\n    }\n  }\n\n  // Update phone if provided and different\n  if (data.phone && ATTRIBUTE_IDS.phone) {\n    const existingPhones = existingPerson?.values[ATTRIBUTE_IDS.phone] || [];\n    const hasPhone = existingPhones.some(p => p.phone_number === data.phone);\n    \n    if (!hasPhone) {\n      values[ATTRIBUTE_IDS.phone] = [...existingPhones, { phone_number: data.phone }];\n      console.log('üìû Adding phone:', data.phone);\n    } else {\n      console.log('üìû Phone already exists:', data.phone);\n    }\n  }\n\n  // Update notes if provided (append to existing notes)\n  if (data.notes && ATTRIBUTE_IDS.notes) {\n    const existingNotes = existingPerson?.values[ATTRIBUTE_IDS.notes] || '';\n    const newNotes = existingNotes ? `${existingNotes}\\n${data.notes}` : data.notes;\n    \n    if (newNotes !== existingNotes) {\n      values[ATTRIBUTE_IDS.notes] = newNotes;\n      console.log('üìù Updating notes from:', `\"${existingNotes}\"`, 'to:', `\"${newNotes}\"`);\n    }\n  }\n\n  if (Object.keys(values).length === 0) {\n    console.log('‚ÑπÔ∏è No updates needed for person - all fields are the same');\n    return recordId;\n  }\n\n  console.log('üì¶ Update payload:', JSON.stringify(values, null, 2));\n\n  const payload = JSON.stringify({ data: { values } });\n\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records/${recordId}`, {\n    method: \"PATCH\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: payload\n  });\n\n  const json = await res.json();\n  if (!res.ok) {\n    console.error(\"‚ùå Person update error:\", json);\n    throw new Error(`Failed to update person: ${JSON.stringify(json)}`);\n  } else {\n    console.log(\"‚úÖ Person updated successfully:\", recordId);\n  }\n\n  return recordId;\n}\n\nasync function queryPersonByName(name) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  \n  console.log(`üîç Searching for person: \"${name}\"`);\n\n  // First, get all people and search through them\n  // This is more reliable than Attio's query filtering which can be finicky\n  let payload = {\n    limit: 100 // Adjust based on your needs\n  };\n\n  let res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records`, {\n    method: \"GET\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n    }\n  });\n\n  if (!res.ok) {\n    console.error(\"‚ùå Failed to fetch people records:\", res.status);\n    return null;\n  }\n\n  let json = await res.json();\n  \n  if (!json.data || json.data.length === 0) {\n    console.log(\"‚ÑπÔ∏è No people found in database\");\n    return null;\n  }\n\n  console.log(`üìã Found ${json.data.length} people in database`);\n\n  // Search through all people for exact and fuzzy matches\n  const searchName = name.toLowerCase().trim();\n  \n  // First pass: exact full name match\n  for (const person of json.data) {\n    const personName = person.values[ATTRIBUTE_IDS.name]?.[0];\n    if (personName) {\n      const fullName = personName.full_name?.toLowerCase().trim();\n      if (fullName === searchName) {\n        console.log(`‚úÖ Found exact match: \"${fullName}\" (ID: ${person.id.record_id})`);\n        return person;\n      }\n    }\n  }\n\n  // Second pass: first name + last name combination match\n  const [searchFirst, ...searchRestParts] = searchName.split(' ');\n  const searchLast = searchRestParts.join(' ');\n\n  for (const person of json.data) {\n    const personName = person.values[ATTRIBUTE_IDS.name]?.[0];\n    if (personName) {\n      const firstName = personName.first_name?.toLowerCase().trim();\n      const lastName = personName.last_name?.toLowerCase().trim();\n      \n      if (firstName === searchFirst && \n          (searchLast === '' || lastName === searchLast)) {\n        console.log(`‚úÖ Found name parts match: \"${firstName} ${lastName}\" (ID: ${person.id.record_id})`);\n        return person;\n      }\n    }\n  }\n\n  // Third pass: fuzzy match (contains)\n  for (const person of json.data) {\n    const personName = person.values[ATTRIBUTE_IDS.name]?.[0];\n    if (personName) {\n      const fullName = personName.full_name?.toLowerCase().trim();\n      if (fullName && (fullName.includes(searchFirst) || searchName.includes(fullName))) {\n        console.log(`‚úÖ Found fuzzy match: \"${fullName}\" (ID: ${person.id.record_id})`);\n        return person;\n      }\n    }\n  }\n\n  console.log(`‚ùå No match found for: \"${name}\"`);\n  return null;\n}\n\n// ========== TASKS ==========\n\nasync function upsertTask(data, linkedPersonId = null) {\n  console.log('üìã Creating task:', data.description);\n  \n  const taskContent = data.description;\n  \n  const payload = {\n    data: {\n      content: taskContent,\n      format: \"plaintext\",\n      deadline_at: data.due_date,\n      is_completed: false,\n      assignees: []\n    }\n  };\n\n  // Link to person if we have an ID\n  if (linkedPersonId) {\n    payload.data.linked_records = [{\n      target_object: \"people\",\n      target_record_id: linkedPersonId\n    }];\n  }\n\n  console.log(\"üì¶ Task payload:\", JSON.stringify(payload, null, 2));\n\n  const res = await fetch(`${ATTIO_API_BASE}/tasks`, {\n    method: \"POST\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n\n  const json = await res.json();\n  if (res.ok) {\n    console.log(\"‚úÖ Task created:\", json.data?.id);\n    return json.data?.id;\n  } else {\n    console.error(\"‚ùå Task creation failed:\", json);\n    throw new Error(`Failed to create task: ${JSON.stringify(json)}`);\n  }\n}\n\n// ========== UTILITY FUNCTIONS ==========\n\nasync function getAttributeIds(objectSlug) {\n  if (attributeCache[objectSlug]) return attributeCache[objectSlug];\n\n  const objectId = await getObjectIdBySlug(objectSlug);\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${objectId}/attributes`, {\n    headers: { Authorization: BEARER_TOKEN }\n  });\n\n  const json = await res.json();\n  const attributes = {};\n  \n  if (json.data) {\n    json.data.forEach(attr => {\n      attributes[attr.api_slug] = attr.id.attribute_id;\n    });\n  }\n\n  attributeCache[objectSlug] = attributes;\n  console.log(`üìã Cached attributes for ${objectSlug}:`, attributes);\n  return attributes;\n}\n\n// Call this once to populate your attribute IDs\nasync function initializeAttributeIds() {\n  try {\n    const peopleAttributes = await getAttributeIds('people');\n    console.log('People attributes:', peopleAttributes);\n    \n    // Update ATTRIBUTE_IDS with actual values\n    ATTRIBUTE_IDS.email = peopleAttributes.email_addresses;\n    ATTRIBUTE_IDS.phone = peopleAttributes.phone_numbers;\n    ATTRIBUTE_IDS.notes = peopleAttributes.notes;\n    \n    console.log('‚úÖ Attribute IDs initialized');\n  } catch (err) {\n    console.error('‚ùå Failed to initialize attribute IDs:', err);\n  }\n}\n\nexport { sendToAttio, initializeAttributeIds };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}