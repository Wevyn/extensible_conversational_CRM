{"ast":null,"code":"// attio.js\nconst ATTIO_API_BASE = \"https://api.attio.com/v2\";\nconst BEARER_TOKEN = \"Bearer e01cca9d5d70d62535755e3f1609118082790728f8c98dbd0b3f9cce1aae3f53\";\n\n// Replace with dynamic ID lookup in future\nconst PEOPLE_OBJECT_ID = \"3a190831-e061-4b7f-af02-644a2ff25c04\";\n\n// MAIN DISPATCHER\nasync function sendToAttio(structuredUpdates) {\n  for (const item of structuredUpdates) {\n    try {\n      ensureFields(item);\n      const intent = detectIntent(item);\n      if (item.type === 'person') {\n        if (intent === 'delete') {\n          await deletePersonByName(item.name);\n        } else {\n          await upsertPerson(item);\n        }\n      }\n      if (item.type === 'task') {\n        if (intent === 'delete') {\n          await deleteTaskByDescription(item.description);\n        } else {\n          await upsertTask(item);\n        }\n      }\n    } catch (err) {\n      console.error(\"‚ùå Failed to sync item:\", item, err);\n    }\n  }\n}\n\n// DETECT INTENT BASED ON FIELD CLUES\nfunction detectIntent(item) {\n  const txt = (item.notes || item.description || \"\").toLowerCase();\n  if (txt.includes(\"remove\") || txt.includes(\"no longer\") || txt.includes(\"cancel\")) return \"delete\";\n  if (txt.includes(\"changed\") || txt.includes(\"update\")) return \"update\";\n  return \"upsert\";\n}\n\n// ENSURE REQUIRED STRUCTURE\nfunction ensureFields(item) {\n  if (item.type === \"person\") {\n    item.name = item.name || \"Unknown\";\n    item.notes = item.notes || \"\";\n  }\n  if (item.type === \"task\") {\n    item.description = item.description || \"Untitled task\";\n    item.due_date = parseDateTime(item.due_date, item.due_time);\n    item.linked_records = item.linked_records || [];\n    item.assignees = item.assignees || [];\n  }\n}\n\n// TIME HANDLER\nfunction parseDateTime(dueDate, dueTime) {\n  try {\n    let date = new Date();\n    if (dueDate !== null && dueDate !== void 0 && dueDate.toLowerCase().includes(\"tomorrow\")) {\n      date.setDate(date.getDate() + 1);\n    } else {\n      const parsed = new Date(dueDate);\n      if (!isNaN(parsed)) date = parsed;\n    }\n    if (dueTime) {\n      const [timePart, meridian] = dueTime.split(' ');\n      let [hour, minute] = timePart.split(':').map(Number);\n      if (meridian !== null && meridian !== void 0 && meridian.toLowerCase().includes('p') && hour < 12) hour += 12;\n      if (meridian !== null && meridian !== void 0 && meridian.toLowerCase().includes('a') && hour === 12) hour = 0;\n      date.setHours(hour || 0, minute || 0, 0, 0);\n    }\n    return date.toISOString();\n  } catch (err) {\n    console.warn('‚ö†Ô∏è Failed to parse datetime:', dueDate, dueTime, err);\n    return new Date().toISOString();\n  }\n}\n\n// ======================= PERSON =======================\n\nasync function upsertPerson(data) {\n  const existingId = await findPersonRecordIdByName(data.name);\n  const [firstName, ...rest] = data.name.split(\" \");\n  const lastName = rest.join(\" \");\n  const payload = {\n    data: {\n      properties: {\n        first_name: firstName,\n        last_name: lastName,\n        notes: data.notes || \"\"\n      }\n    }\n  };\n  const url = existingId ? `${ATTIO_API_BASE}/objects/${PEOPLE_OBJECT_ID}/records/${existingId}` : `${ATTIO_API_BASE}/objects/${PEOPLE_OBJECT_ID}/records`;\n  const method = existingId ? \"PATCH\" : \"POST\";\n  const response = await fetch(url, {\n    method,\n    headers: {\n      \"Authorization\": BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n  const result = await response.json();\n  if (response.ok) {\n    var _result$data;\n    console.log(`‚úÖ Person ${existingId ? \"updated\" : \"created\"}:`, result);\n    return (_result$data = result.data) === null || _result$data === void 0 ? void 0 : _result$data.id;\n  } else {\n    console.error(\"‚ùå Person upsert error:\", result);\n    return null;\n  }\n}\nasync function deletePersonByName(name) {\n  const id = await findPersonRecordIdByName(name);\n  if (!id) {\n    console.warn(\"‚ö†Ô∏è Person not found for deletion:\", name);\n    return;\n  }\n  const url = `${ATTIO_API_BASE}/objects/${PEOPLE_OBJECT_ID}/records/${id}`;\n  const res = await fetch(url, {\n    method: \"DELETE\",\n    headers: {\n      \"Authorization\": BEARER_TOKEN\n    }\n  });\n  if (res.ok) {\n    console.log(\"üóëÔ∏è Deleted person:\", name);\n  } else {\n    console.error(\"‚ùå Failed to delete person:\", name);\n  }\n}\nasync function findPersonRecordIdByName(name) {\n  var _json$data, _json$data$find;\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${PEOPLE_OBJECT_ID}/records`, {\n    method: \"GET\",\n    headers: {\n      \"Authorization\": BEARER_TOKEN\n    }\n  });\n  const json = await res.json();\n  return ((_json$data = json.data) === null || _json$data === void 0 ? void 0 : (_json$data$find = _json$data.find(entry => {\n    var _entry$properties, _entry$properties2;\n    const full = `${((_entry$properties = entry.properties) === null || _entry$properties === void 0 ? void 0 : _entry$properties.first_name) || \"\"} ${((_entry$properties2 = entry.properties) === null || _entry$properties2 === void 0 ? void 0 : _entry$properties2.last_name) || \"\"}`.trim().toLowerCase();\n    return full === name.toLowerCase();\n  })) === null || _json$data$find === void 0 ? void 0 : _json$data$find.id) || null;\n}\n\n// ======================= TASK =======================\n\nasync function upsertTask(data) {\n  // naive approach: delete if duplicate desc, re-add\n  await deleteTaskByDescription(data.description);\n  const personId = data.link_to_person_name ? await findPersonRecordIdByName(data.link_to_person_name) : null;\n  const payload = {\n    data: {\n      content: data.description,\n      format: \"plaintext\",\n      deadline_at: data.due_date,\n      is_completed: false,\n      linked_records: personId ? [{\n        target_object: \"people\",\n        target_record_id: personId\n      }] : [],\n      assignees: data.assignees || []\n    }\n  };\n  const res = await fetch(`${ATTIO_API_BASE}/tasks`, {\n    method: \"POST\",\n    headers: {\n      \"Authorization\": BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n  const result = await res.json();\n  if (res.ok) {\n    console.log(\"‚úÖ Task created:\", result);\n  } else {\n    console.error(\"‚ùå Task creation error:\", result);\n  }\n}\nasync function deleteTaskByDescription(desc) {\n  var _json$data2;\n  const res = await fetch(`${ATTIO_API_BASE}/tasks`, {\n    method: \"GET\",\n    headers: {\n      \"Authorization\": BEARER_TOKEN\n    }\n  });\n  const json = await res.json();\n  const match = (_json$data2 = json.data) === null || _json$data2 === void 0 ? void 0 : _json$data2.find(task => {\n    var _task$content;\n    return ((_task$content = task.content) === null || _task$content === void 0 ? void 0 : _task$content.trim().toLowerCase()) === desc.trim().toLowerCase();\n  });\n  if (!match) return;\n  const taskId = match.id;\n  const del = await fetch(`${ATTIO_API_BASE}/tasks/${taskId}`, {\n    method: \"DELETE\",\n    headers: {\n      \"Authorization\": BEARER_TOKEN\n    }\n  });\n  if (del.ok) {\n    console.log(\"üóëÔ∏è Deleted task:\", desc);\n  } else {\n    console.error(\"‚ùå Failed to delete task:\", desc);\n  }\n}\nexport { sendToAttio };","map":{"version":3,"names":["ATTIO_API_BASE","BEARER_TOKEN","PEOPLE_OBJECT_ID","sendToAttio","structuredUpdates","item","ensureFields","intent","detectIntent","type","deletePersonByName","name","upsertPerson","deleteTaskByDescription","description","upsertTask","err","console","error","txt","notes","toLowerCase","includes","due_date","parseDateTime","due_time","linked_records","assignees","dueDate","dueTime","date","Date","setDate","getDate","parsed","isNaN","timePart","meridian","split","hour","minute","map","Number","setHours","toISOString","warn","data","existingId","findPersonRecordIdByName","firstName","rest","lastName","join","payload","properties","first_name","last_name","url","method","response","fetch","headers","body","JSON","stringify","result","json","ok","_result$data","log","id","res","_json$data","_json$data$find","find","entry","_entry$properties","_entry$properties2","full","trim","personId","link_to_person_name","content","format","deadline_at","is_completed","target_object","target_record_id","desc","_json$data2","match","task","_task$content","taskId","del"],"sources":["/Users/Aditya/ConversationalAI_CRM_Attio/src/attio.js"],"sourcesContent":["// attio.js\nconst ATTIO_API_BASE = \"https://api.attio.com/v2\";\nconst BEARER_TOKEN = \"Bearer e01cca9d5d70d62535755e3f1609118082790728f8c98dbd0b3f9cce1aae3f53\";\n\n// Replace with dynamic ID lookup in future\nconst PEOPLE_OBJECT_ID = \"3a190831-e061-4b7f-af02-644a2ff25c04\";\n\n// MAIN DISPATCHER\nasync function sendToAttio(structuredUpdates) {\n  for (const item of structuredUpdates) {\n    try {\n      ensureFields(item);\n\n      const intent = detectIntent(item);\n\n      if (item.type === 'person') {\n        if (intent === 'delete') {\n          await deletePersonByName(item.name);\n        } else {\n          await upsertPerson(item);\n        }\n      }\n\n      if (item.type === 'task') {\n        if (intent === 'delete') {\n          await deleteTaskByDescription(item.description);\n        } else {\n          await upsertTask(item);\n        }\n      }\n\n    } catch (err) {\n      console.error(\"‚ùå Failed to sync item:\", item, err);\n    }\n  }\n}\n\n// DETECT INTENT BASED ON FIELD CLUES\nfunction detectIntent(item) {\n  const txt = (item.notes || item.description || \"\").toLowerCase();\n  if (txt.includes(\"remove\") || txt.includes(\"no longer\") || txt.includes(\"cancel\")) return \"delete\";\n  if (txt.includes(\"changed\") || txt.includes(\"update\")) return \"update\";\n  return \"upsert\";\n}\n\n// ENSURE REQUIRED STRUCTURE\nfunction ensureFields(item) {\n  if (item.type === \"person\") {\n    item.name = item.name || \"Unknown\";\n    item.notes = item.notes || \"\";\n  }\n\n  if (item.type === \"task\") {\n    item.description = item.description || \"Untitled task\";\n    item.due_date = parseDateTime(item.due_date, item.due_time);\n    item.linked_records = item.linked_records || [];\n    item.assignees = item.assignees || [];\n  }\n}\n\n// TIME HANDLER\nfunction parseDateTime(dueDate, dueTime) {\n  try {\n    let date = new Date();\n    if (dueDate?.toLowerCase().includes(\"tomorrow\")) {\n      date.setDate(date.getDate() + 1);\n    } else {\n      const parsed = new Date(dueDate);\n      if (!isNaN(parsed)) date = parsed;\n    }\n\n    if (dueTime) {\n      const [timePart, meridian] = dueTime.split(' ');\n      let [hour, minute] = timePart.split(':').map(Number);\n      if (meridian?.toLowerCase().includes('p') && hour < 12) hour += 12;\n      if (meridian?.toLowerCase().includes('a') && hour === 12) hour = 0;\n      date.setHours(hour || 0, minute || 0, 0, 0);\n    }\n\n    return date.toISOString();\n  } catch (err) {\n    console.warn('‚ö†Ô∏è Failed to parse datetime:', dueDate, dueTime, err);\n    return new Date().toISOString();\n  }\n}\n\n// ======================= PERSON =======================\n\nasync function upsertPerson(data) {\n  const existingId = await findPersonRecordIdByName(data.name);\n\n  const [firstName, ...rest] = data.name.split(\" \");\n  const lastName = rest.join(\" \");\n\n  const payload = {\n    data: {\n      properties: {\n        first_name: firstName,\n        last_name: lastName,\n        notes: data.notes || \"\",\n      }\n    }\n  };\n\n  const url = existingId\n    ? `${ATTIO_API_BASE}/objects/${PEOPLE_OBJECT_ID}/records/${existingId}`\n    : `${ATTIO_API_BASE}/objects/${PEOPLE_OBJECT_ID}/records`;\n\n  const method = existingId ? \"PATCH\" : \"POST\";\n\n  const response = await fetch(url, {\n    method,\n    headers: {\n      \"Authorization\": BEARER_TOKEN,\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(payload),\n  });\n\n  const result = await response.json();\n  if (response.ok) {\n    console.log(`‚úÖ Person ${existingId ? \"updated\" : \"created\"}:`, result);\n    return result.data?.id;\n  } else {\n    console.error(\"‚ùå Person upsert error:\", result);\n    return null;\n  }\n}\n\nasync function deletePersonByName(name) {\n  const id = await findPersonRecordIdByName(name);\n  if (!id) {\n    console.warn(\"‚ö†Ô∏è Person not found for deletion:\", name);\n    return;\n  }\n\n  const url = `${ATTIO_API_BASE}/objects/${PEOPLE_OBJECT_ID}/records/${id}`;\n  const res = await fetch(url, {\n    method: \"DELETE\",\n    headers: { \"Authorization\": BEARER_TOKEN }\n  });\n\n  if (res.ok) {\n    console.log(\"üóëÔ∏è Deleted person:\", name);\n  } else {\n    console.error(\"‚ùå Failed to delete person:\", name);\n  }\n}\n\nasync function findPersonRecordIdByName(name) {\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${PEOPLE_OBJECT_ID}/records`, {\n    method: \"GET\",\n    headers: { \"Authorization\": BEARER_TOKEN }\n  });\n\n  const json = await res.json();\n  return json.data?.find(entry => {\n    const full = `${entry.properties?.first_name || \"\"} ${entry.properties?.last_name || \"\"}`.trim().toLowerCase();\n    return full === name.toLowerCase();\n  })?.id || null;\n}\n\n// ======================= TASK =======================\n\nasync function upsertTask(data) {\n  // naive approach: delete if duplicate desc, re-add\n  await deleteTaskByDescription(data.description);\n\n  const personId = data.link_to_person_name\n    ? await findPersonRecordIdByName(data.link_to_person_name)\n    : null;\n\n  const payload = {\n    data: {\n      content: data.description,\n      format: \"plaintext\",\n      deadline_at: data.due_date,\n      is_completed: false,\n      linked_records: personId ? [{\n        target_object: \"people\",\n        target_record_id: personId\n      }] : [],\n      assignees: data.assignees || []\n    }\n  };\n\n  const res = await fetch(`${ATTIO_API_BASE}/tasks`, {\n    method: \"POST\",\n    headers: {\n      \"Authorization\": BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n\n  const result = await res.json();\n  if (res.ok) {\n    console.log(\"‚úÖ Task created:\", result);\n  } else {\n    console.error(\"‚ùå Task creation error:\", result);\n  }\n}\n\nasync function deleteTaskByDescription(desc) {\n  const res = await fetch(`${ATTIO_API_BASE}/tasks`, {\n    method: \"GET\",\n    headers: { \"Authorization\": BEARER_TOKEN }\n  });\n\n  const json = await res.json();\n  const match = json.data?.find(task =>\n    task.content?.trim().toLowerCase() === desc.trim().toLowerCase()\n  );\n\n  if (!match) return;\n\n  const taskId = match.id;\n  const del = await fetch(`${ATTIO_API_BASE}/tasks/${taskId}`, {\n    method: \"DELETE\",\n    headers: { \"Authorization\": BEARER_TOKEN }\n  });\n\n  if (del.ok) {\n    console.log(\"üóëÔ∏è Deleted task:\", desc);\n  } else {\n    console.error(\"‚ùå Failed to delete task:\", desc);\n  }\n}\n\nexport { sendToAttio };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}