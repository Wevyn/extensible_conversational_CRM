{"ast":null,"code":"// attio.js\nconst ATTIO_API_BASE = \"https://api.attio.com/v2\";\nconst BEARER_TOKEN = \"Bearer e01cca9d5d70d62535755e3f1609118082790728f8c98dbd0b3f9cce1aae3f53\";\n\n// In-memory cache for object IDs (e.g., people, companies)\nconst objectCache = {};\n\n// MAIN DISPATCHER\nasync function sendToAttio(structuredUpdates) {\n  for (const item of structuredUpdates) {\n    try {\n      ensureFields(item);\n      const intent = detectIntent(item);\n      if (item.type === \"person\") {\n        if (intent === \"delete\") {\n          await deletePersonByName(item.name);\n        } else {\n          await upsertPerson(item);\n        }\n      }\n      if (item.type === \"task\") {\n        if (intent === \"delete\") {\n          await deleteTaskByDescription(item.description);\n        } else {\n          await upsertTask(item);\n        }\n      }\n    } catch (err) {\n      console.error(\"‚ùå Failed to process item:\", item, err);\n    }\n  }\n}\n\n// ========== OBJECT ID RESOLUTION ==========\n\nasync function getObjectIdBySlug(slug) {\n  var _json$data;\n  if (objectCache[slug]) return objectCache[slug];\n  const res = await fetch(`${ATTIO_API_BASE}/objects`, {\n    headers: {\n      Authorization: BEARER_TOKEN\n    }\n  });\n  const json = await res.json();\n  const match = (_json$data = json.data) === null || _json$data === void 0 ? void 0 : _json$data.find(obj => obj.api_slug.trim().toLowerCase() === slug.trim().toLowerCase());\n  if (match) {\n    objectCache[slug] = match.id;\n    return match.id;\n  } else {\n    throw new Error(`‚ùå Could not find object with slug \"${slug}\"`);\n  }\n}\n\n// ========== UTILS ==========\n\nfunction detectIntent(item) {\n  const txt = (item.notes || item.description || \"\").toLowerCase();\n  if (txt.includes(\"remove\") || txt.includes(\"cancel\")) return \"delete\";\n  if (txt.includes(\"changed\") || txt.includes(\"update\")) return \"update\";\n  return \"upsert\";\n}\nfunction ensureFields(item) {\n  if (item.type === \"person\") {\n    item.name = item.name || \"Unknown\";\n    item.notes = item.notes || \"\";\n  }\n  if (item.type === \"task\") {\n    item.description = item.description || \"Untitled task\";\n    item.due_date = parseDateTime(item.due_date, item.due_time);\n    item.linked_records = item.linked_records || [];\n    item.assignees = item.assignees || [];\n  }\n}\nfunction parseDateTime(dueDate, dueTime) {\n  try {\n    let date = new Date();\n    if (dueDate !== null && dueDate !== void 0 && dueDate.toLowerCase().includes(\"tomorrow\")) {\n      date.setDate(date.getDate() + 1);\n    } else {\n      const parsed = new Date(dueDate);\n      if (!isNaN(parsed)) date = parsed;\n    }\n    if (dueTime) {\n      const [timePart, meridian] = dueTime.split(\" \");\n      let [hour, minute] = timePart.split(\":\").map(Number);\n      if (meridian !== null && meridian !== void 0 && meridian.toLowerCase().includes(\"p\") && hour < 12) hour += 12;\n      if (meridian !== null && meridian !== void 0 && meridian.toLowerCase().includes(\"a\") && hour === 12) hour = 0;\n      date.setHours(hour || 0, minute || 0, 0, 0);\n    }\n    return date.toISOString();\n  } catch {\n    return new Date().toISOString();\n  }\n}\n\n// ========== PERSONS ==========\n\nasync function upsertPerson(data) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  const existingId = await findPersonRecordIdByName(data.name);\n  const [firstName, ...rest] = data.name.split(\" \");\n  const lastName = rest.join(\" \");\n  const payload = {\n    data: {\n      properties: {\n        first_name: firstName,\n        last_name: lastName,\n        notes: data.notes\n      }\n    }\n  };\n  const url = existingId ? `${ATTIO_API_BASE}/objects/${peopleId}/records/${existingId}` : `${ATTIO_API_BASE}/objects/${peopleId}/records`;\n  const method = existingId ? \"PATCH\" : \"POST\";\n  const res = await fetch(url, {\n    method,\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n  const json = await res.json();\n  if (res.ok) {\n    var _json$data2;\n    console.log(`‚úÖ Person ${existingId ? \"updated\" : \"created\"}:`, json);\n    return (_json$data2 = json.data) === null || _json$data2 === void 0 ? void 0 : _json$data2.id;\n  } else {\n    console.error(\"‚ùå Person sync error:\", json);\n    return null;\n  }\n}\nasync function deletePersonByName(name) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  const id = await findPersonRecordIdByName(name);\n  if (!id) return console.warn(\"‚ö†Ô∏è Person not found:\", name);\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records/${id}`, {\n    method: \"DELETE\",\n    headers: {\n      Authorization: BEARER_TOKEN\n    }\n  });\n  if (res.ok) {\n    console.log(\"üóëÔ∏è Deleted person:\", name);\n  } else {\n    console.error(\"‚ùå Failed to delete person:\", name);\n  }\n}\nasync function findPersonRecordIdByName(name) {\n  var _json$data3;\n  const peopleId = await getObjectIdBySlug(\"people\");\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records`, {\n    headers: {\n      Authorization: BEARER_TOKEN\n    }\n  });\n  const json = await res.json();\n  const match = (_json$data3 = json.data) === null || _json$data3 === void 0 ? void 0 : _json$data3.find(entry => {\n    var _entry$properties, _entry$properties2;\n    const full = `${((_entry$properties = entry.properties) === null || _entry$properties === void 0 ? void 0 : _entry$properties.first_name) || \"\"} ${((_entry$properties2 = entry.properties) === null || _entry$properties2 === void 0 ? void 0 : _entry$properties2.last_name) || \"\"}`.trim().toLowerCase();\n    return full === name.toLowerCase();\n  });\n  return (match === null || match === void 0 ? void 0 : match.id) || null;\n}\n\n// ========== TASKS ==========\n\nasync function upsertTask(data) {\n  await deleteTaskByDescription(data.description); // Prevent duplicates\n\n  const personId = data.link_to_person_name ? await findPersonRecordIdByName(data.link_to_person_name) : null;\n  const payload = {\n    data: {\n      content: data.description,\n      format: \"plaintext\",\n      deadline_at: data.due_date,\n      is_completed: false,\n      linked_records: personId ? [{\n        target_object: \"people\",\n        target_record_id: personId\n      }] : [],\n      assignees: data.assignees\n    }\n  };\n  const res = await fetch(`${ATTIO_API_BASE}/tasks`, {\n    method: \"POST\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n  const json = await res.json();\n  if (res.ok) {\n    console.log(\"‚úÖ Task created:\", json);\n  } else {\n    console.error(\"‚ùå Task creation error:\", json);\n  }\n}\nasync function deleteTaskByDescription(desc) {\n  var _json$data4;\n  const res = await fetch(`${ATTIO_API_BASE}/tasks`, {\n    headers: {\n      Authorization: BEARER_TOKEN\n    }\n  });\n  const json = await res.json();\n  const match = (_json$data4 = json.data) === null || _json$data4 === void 0 ? void 0 : _json$data4.find(t => {\n    var _t$content;\n    return ((_t$content = t.content) === null || _t$content === void 0 ? void 0 : _t$content.trim().toLowerCase()) === desc.trim().toLowerCase();\n  });\n  if (!match) return;\n  const del = await fetch(`${ATTIO_API_BASE}/tasks/${match.id}`, {\n    method: \"DELETE\",\n    headers: {\n      Authorization: BEARER_TOKEN\n    }\n  });\n  if (del.ok) {\n    console.log(\"üóëÔ∏è Deleted task:\", desc);\n  } else {\n    console.error(\"‚ùå Failed to delete task:\", desc);\n  }\n}\nexport { sendToAttio };","map":{"version":3,"names":["ATTIO_API_BASE","BEARER_TOKEN","objectCache","sendToAttio","structuredUpdates","item","ensureFields","intent","detectIntent","type","deletePersonByName","name","upsertPerson","deleteTaskByDescription","description","upsertTask","err","console","error","getObjectIdBySlug","slug","_json$data","res","fetch","headers","Authorization","json","match","data","find","obj","api_slug","trim","toLowerCase","id","Error","txt","notes","includes","due_date","parseDateTime","due_time","linked_records","assignees","dueDate","dueTime","date","Date","setDate","getDate","parsed","isNaN","timePart","meridian","split","hour","minute","map","Number","setHours","toISOString","peopleId","existingId","findPersonRecordIdByName","firstName","rest","lastName","join","payload","properties","first_name","last_name","url","method","body","JSON","stringify","ok","_json$data2","log","warn","_json$data3","entry","_entry$properties","_entry$properties2","full","personId","link_to_person_name","content","format","deadline_at","is_completed","target_object","target_record_id","desc","_json$data4","t","_t$content","del"],"sources":["/Users/Aditya/ConversationalAI_CRM_Attio/src/attio.js"],"sourcesContent":["// attio.js\nconst ATTIO_API_BASE = \"https://api.attio.com/v2\";\nconst BEARER_TOKEN = \"Bearer e01cca9d5d70d62535755e3f1609118082790728f8c98dbd0b3f9cce1aae3f53\";\n\n// In-memory cache for object IDs (e.g., people, companies)\nconst objectCache = {};\n\n// MAIN DISPATCHER\nasync function sendToAttio(structuredUpdates) {\n  for (const item of structuredUpdates) {\n    try {\n      ensureFields(item);\n      const intent = detectIntent(item);\n\n      if (item.type === \"person\") {\n        if (intent === \"delete\") {\n          await deletePersonByName(item.name);\n        } else {\n          await upsertPerson(item);\n        }\n      }\n\n      if (item.type === \"task\") {\n        if (intent === \"delete\") {\n          await deleteTaskByDescription(item.description);\n        } else {\n          await upsertTask(item);\n        }\n      }\n\n    } catch (err) {\n      console.error(\"‚ùå Failed to process item:\", item, err);\n    }\n  }\n}\n\n// ========== OBJECT ID RESOLUTION ==========\n\nasync function getObjectIdBySlug(slug) {\n  if (objectCache[slug]) return objectCache[slug];\n\n  const res = await fetch(`${ATTIO_API_BASE}/objects`, {\n    headers: { Authorization: BEARER_TOKEN }\n  });\n\n  const json = await res.json();\n  const match = json.data?.find(obj => obj.api_slug.trim().toLowerCase() === slug.trim().toLowerCase());\n\n\n  if (match) {\n    objectCache[slug] = match.id;\n    return match.id;\n  } else {\n    throw new Error(`‚ùå Could not find object with slug \"${slug}\"`);\n  }\n}\n\n// ========== UTILS ==========\n\nfunction detectIntent(item) {\n  const txt = (item.notes || item.description || \"\").toLowerCase();\n  if (txt.includes(\"remove\") || txt.includes(\"cancel\")) return \"delete\";\n  if (txt.includes(\"changed\") || txt.includes(\"update\")) return \"update\";\n  return \"upsert\";\n}\n\nfunction ensureFields(item) {\n  if (item.type === \"person\") {\n    item.name = item.name || \"Unknown\";\n    item.notes = item.notes || \"\";\n  }\n\n  if (item.type === \"task\") {\n    item.description = item.description || \"Untitled task\";\n    item.due_date = parseDateTime(item.due_date, item.due_time);\n    item.linked_records = item.linked_records || [];\n    item.assignees = item.assignees || [];\n  }\n}\n\nfunction parseDateTime(dueDate, dueTime) {\n  try {\n    let date = new Date();\n    if (dueDate?.toLowerCase().includes(\"tomorrow\")) {\n      date.setDate(date.getDate() + 1);\n    } else {\n      const parsed = new Date(dueDate);\n      if (!isNaN(parsed)) date = parsed;\n    }\n\n    if (dueTime) {\n      const [timePart, meridian] = dueTime.split(\" \");\n      let [hour, minute] = timePart.split(\":\").map(Number);\n      if (meridian?.toLowerCase().includes(\"p\") && hour < 12) hour += 12;\n      if (meridian?.toLowerCase().includes(\"a\") && hour === 12) hour = 0;\n      date.setHours(hour || 0, minute || 0, 0, 0);\n    }\n\n    return date.toISOString();\n  } catch {\n    return new Date().toISOString();\n  }\n}\n\n// ========== PERSONS ==========\n\nasync function upsertPerson(data) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  const existingId = await findPersonRecordIdByName(data.name);\n\n  const [firstName, ...rest] = data.name.split(\" \");\n  const lastName = rest.join(\" \");\n\n  const payload = {\n    data: {\n      properties: {\n        first_name: firstName,\n        last_name: lastName,\n        notes: data.notes\n      }\n    }\n  };\n\n  const url = existingId\n    ? `${ATTIO_API_BASE}/objects/${peopleId}/records/${existingId}`\n    : `${ATTIO_API_BASE}/objects/${peopleId}/records`;\n\n  const method = existingId ? \"PATCH\" : \"POST\";\n\n  const res = await fetch(url, {\n    method,\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n\n  const json = await res.json();\n\n  if (res.ok) {\n    console.log(`‚úÖ Person ${existingId ? \"updated\" : \"created\"}:`, json);\n    return json.data?.id;\n  } else {\n    console.error(\"‚ùå Person sync error:\", json);\n    return null;\n  }\n}\n\nasync function deletePersonByName(name) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n  const id = await findPersonRecordIdByName(name);\n  if (!id) return console.warn(\"‚ö†Ô∏è Person not found:\", name);\n\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records/${id}`, {\n    method: \"DELETE\",\n    headers: { Authorization: BEARER_TOKEN }\n  });\n\n  if (res.ok) {\n    console.log(\"üóëÔ∏è Deleted person:\", name);\n  } else {\n    console.error(\"‚ùå Failed to delete person:\", name);\n  }\n}\n\nasync function findPersonRecordIdByName(name) {\n  const peopleId = await getObjectIdBySlug(\"people\");\n\n  const res = await fetch(`${ATTIO_API_BASE}/objects/${peopleId}/records`, {\n    headers: { Authorization: BEARER_TOKEN }\n  });\n\n  const json = await res.json();\n  const match = json.data?.find(entry => {\n    const full = `${entry.properties?.first_name || \"\"} ${entry.properties?.last_name || \"\"}`.trim().toLowerCase();\n    return full === name.toLowerCase();\n  });\n\n  return match?.id || null;\n}\n\n// ========== TASKS ==========\n\nasync function upsertTask(data) {\n  await deleteTaskByDescription(data.description); // Prevent duplicates\n\n  const personId = data.link_to_person_name\n    ? await findPersonRecordIdByName(data.link_to_person_name)\n    : null;\n\n  const payload = {\n    data: {\n      content: data.description,\n      format: \"plaintext\",\n      deadline_at: data.due_date,\n      is_completed: false,\n      linked_records: personId\n        ? [{ target_object: \"people\", target_record_id: personId }]\n        : [],\n      assignees: data.assignees\n    }\n  };\n\n  const res = await fetch(`${ATTIO_API_BASE}/tasks`, {\n    method: \"POST\",\n    headers: {\n      Authorization: BEARER_TOKEN,\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify(payload)\n  });\n\n  const json = await res.json();\n\n  if (res.ok) {\n    console.log(\"‚úÖ Task created:\", json);\n  } else {\n    console.error(\"‚ùå Task creation error:\", json);\n  }\n}\n\nasync function deleteTaskByDescription(desc) {\n  const res = await fetch(`${ATTIO_API_BASE}/tasks`, {\n    headers: { Authorization: BEARER_TOKEN }\n  });\n\n  const json = await res.json();\n\n  const match = json.data?.find(\n    t => t.content?.trim().toLowerCase() === desc.trim().toLowerCase()\n  );\n\n  if (!match) return;\n\n  const del = await fetch(`${ATTIO_API_BASE}/tasks/${match.id}`, {\n    method: \"DELETE\",\n    headers: { Authorization: BEARER_TOKEN }\n  });\n\n  if (del.ok) {\n    console.log(\"üóëÔ∏è Deleted task:\", desc);\n  } else {\n    console.error(\"‚ùå Failed to delete task:\", desc);\n  }\n}\n\nexport { sendToAttio };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}